package _03数据类型;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/*
 * 方法：方法是独立的代码块，不属于任何类或对象，可以通过方法名直接调用
 * 方法：当方法定义在类内部时就是方法，必须通过类本身或类的实例来调用。方法的第一个参数通常都是隐藏参数 self（实例方法）或 cls（类方法），用于访问对象或类的数据
 * 
 * Java 的面向对象做得很彻底，必须先有类后有“方法”，也就是说“方法”必须定义类内部，因此 Java 里没有方法只有方法
 * Java 里方法不是一等公民，所以严格来讲方法不是一种数据类型，不应该放到数据类型这里学习。但在学习很多其它语言时，都是学完常用数据类型就学方法，索性就放到这里来学了
 * 
 * 方法是什么？方法是指一段代码的集合，它由方法的修饰符、方法的返回值、方法名、方法的参数、方法的执行体五大部分组成，格式为：
 * 方法的修饰符 方法的返回值 方法名(方法的参数) {
 *   方法的执行体
 * }
 * 
 * 方法的修饰符：public、static、abstract等，不同的修饰符有不同的作用
 * 方法名：拿到方法名就是拿到了方法的地址
 * 其它三部分：下面说
 */
public class _03方法 {
	
	/*
	  1、方法的声明
	  在C语言里，如果一个方法的实现发生在该方法的调用之前，那么这个方法是不需要声明的
	  在JS里，因为所有方法的实现都会被提升到代码头部，所以我们不需要专门声明一个方法，直接实现和调用就可以了
	  在Java里，因为编译器在编译时是全局统筹地解析整个类的结构​（包括所有方法、字段等），而不是从上到下逐行解析，然后生成字节码，也就是说方法的定义顺序并不重要，所以我们不需要专门声明一个方法，直接实现和调用就可以了
	*/
	
	/*
	  2、方法的实现
	*/
	// 无参无返回值
	public static void fun() {
	  System.err.println(10);
	}

	// 无参有返回值
	public static Integer fun1() {
	  return 10;
	}

	// 有参无返回值
	public static void fun2(Integer i1, Integer i2) {
		System.err.println(i1 + i2);
	}

	// 有参有返回值
	public static Integer fun3(Integer i1, Integer i2) {
	  return i1 + i2;
	}
	
	public static void main(String[] args) {
		/*
		  3、方法的调用
		*/
		fun(); // 10
		System.err.println(fun1()); // 10
		fun2(10, 20); // 30
		System.err.println(fun3(10, 20)); // 30
		
		int num = 11;
		fun5(num);
		System.out.println(num); // 11
		
		List<Integer> nums = new ArrayList<Integer>(Arrays.asList(11, 12));
		fun6(nums);
		System.out.println(nums); // [13, 14]
		
		fun7(11, 12);
	}
	
	/*
	  4、方法的参数补充
	*/
	/* 
	  （1）可选参数和必选参数
		跟Swift、Dart、JS不一样，Java里没有可选参数和必选参数之分，都是必选参数，而且不能给参数默认值
	*/
	/* 
	  （2）参数的值传递和引用传递
		如果方法的参数是基本数据类型，那么参数的传递方式为值传递，方法内部修改参数的值不会影响到外面的值
		如果方法的参数是对象数据类型，那么参数的传递方式为引用传递，方法内部修改参数的值会影响到外面的值
	*/
	public static void fun5(int i) {
		i = 12;
	}
	
	public static void fun6(List<Integer> is) {
		is.set(0, 13);
		is.set(1, 14);
	}
	
	/*
	  （3）方法的可变参数（数据类型后面加上...）——本质是一个数组
		如果参数的个数是不确定的，那我们可以用可变参数，但是一个方法只能有一个可变参数，并且可变参数必须是参数列表里的最后一个参数
	*/
	private static void fun7(Integer... agrs) {
		/*
		 * [Ljava.lang.Integer;@15db9742，可见可变参数其实变成了一个数组
		 * 
		 * “[”：代表是一个数组
		 * “Ljava.lang.Integer;”：代表数组里存储的数据类型
		 * “@15db9742”：是引用类型的哈希值，也是一个对象的唯一标识，Java里我们没办法获取一个对象的内存地址，因为Java不希望开发者关注内存相关的事情，所以就用哈希值吧
		 */
		System.out.println(agrs);
	}
	
	/*
	  5、Java里方法不是一等公民
	  Java里方法不是一等公民，这就意味着方法不可以赋值给一个变量，或者作为另一个方法的参数和返回值
	*/
	
	/*
	  6、Lambda表达式
	  OC里叫Block、Swift里叫闭包、Dart里叫匿名方法、Java|C++里叫Lambda表达式、JS里叫匿名方法、TS里叫匿名方法
	  详见匿名类和Lambda表达式章节
	*/
	// 我们可以从方法是一等公民的角度来考虑匿名方法的应用场景
	// 场景1：匿名方法可以赋值给一个变量供将来调用，也就是说它不能单独存在，因为它单独存在没有意义，它没有名字将来你拿什么调用它，常用来做一个类属性类型的callback，比如我们经常在一个view里写一些点击的回调方法等，这些回调方法就是类的属性，将来我们就会把匿名方法赋值给这些属性
	// 场景2：我们可以把匿名方法作为另一个方法的参数来使用，也就是我们常说的回调，常用来方法参数类型的callback，比如我们经常在网络请求的方法里添加请求成功和请求失败的回调等，将来我们就会把匿名方法赋值给这些参数
	// 场景3：我们可以把匿名方法作为另一个方法的返回值来使用，类似于方法生成器的感觉，不过这个一般需要和第1条连用，不常用
	// 场景4：此外，立即执行的方法优先考虑使用匿名方法，常用来初始化需要一坨代码才能初始化的属性，注意立即执行方法要用()包一下
	// (function (方法的参数): 方法的返回值 {
	//   方法的执行体
	// })(方法的参数);
	
}
