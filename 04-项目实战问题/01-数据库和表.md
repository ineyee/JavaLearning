实际开发中，一般都是用 Navicat GUI 工具先把数据库和表创建好，项目里就只做些增删改查操作，很少在项目里通过代码来创建数据库和表。

## ✅ 一、用 Navicat Premium 创建数据库

> 一般来说一个项目对应一个数据库

![image-20260108173651087](01-数据库和表/img/image-20260108173651087.png)

***

![image-20260108173833434](01-数据库和表/img/image-20260108173833434.png)

## ✅ 二、用 Navicat Data Modeler 设计表

Navicat Data Modeler 是一个强大的设计表工具，本机安装 Navicat Data Modeler：

- Navicat Data Modeler 下载地址：https://www.5v13.com/macrj/37949.html
- 下载完双击安装即可，macOS 上会默认安装在应用程序
- Navicat Data Modeler 使用教程：https://www.navicat.com.cn/manual/online_manual/cn/navicat_data_modeler_4/mac_manual/#/about_0

#### ✅ 1、新建模型

> Navicat Data Modeler 里的模型其实就是数据库的设计图纸，我们就是在模型这个东西上设计数据库里一张一张的表，所以模型的名字可以跟数据库的名字保持一致
>
> 一个数据库里可以有多张表 => 一个模型里可以有多张表

![image-20260108152844587](01-数据库和表/img/image-20260108152844587.png)

***

![image-20260108153055403](01-数据库和表/img/image-20260108153055403.png)

***

![image-20260108180110980](01-数据库和表/img/image-20260108180110980.png)

#### ✅ 2、设计表（这里先设计下单表）

> 通过 SQL 语句手动创建表时是这样：
>
> ```mysql
> CREATE TABLE IF NOT EXISTS product (
> 	-- 主键、自增
>   id BIGINT PRIMARY KEY AUTO_INCREMENT,
>   
>   -- 该字段我们定义为非必传，即 DATETIME? 类型而非 DATETIME 类型，因此我们需要提供默认值——当前时间
>   -- 只要我们给这个字段提供了默认值，实际开发中就无需再手动给这个字段赋值了，让数据库自动维护即可
>   -- 无论服务器所在时区是什么时区，MySQL 在自动维护 DATETIME 类型的字段时默认都存储的是零时区的时间，所以客户端拿到时间后展示时需要手动转换为各个时区对应的时间展示；当然有些数据库 GUI 工具——如 Navicat ——在展示这些零时区的时间时可能会转换为当前时区的时间展示，这个我们不用管它；总之，通过 SQL 语句读取到的时间和返回给客户端的时间肯定是零时区的
>   create_time DATETIME DEFAULT(CURRENT_TIMESTAMP),
> 
>   -- 该字段我们定义为非必传，即 DATETIME? 类型而非 DATETIME 类型，因此我们需要提供默认值——当前时间；并且我们设置当更新了某条数据的任意字段时，都用最新的当前时间更新一下该字段
>   -- 只要我们给这个字段提供了默认值，实际开发中就无需再手动给这个字段赋值了，让数据库自动维护即可
>   update_time DATETIME DEFAULT(CURRENT_TIMESTAMP) ON UPDATE CURRENT_TIMESTAMP,
> 
> 	-- 该字段我们定义为必传，即 String 类型而非 String? 类型，因此我们不需要提供默认值
> 	-- 该字段还得唯一
>   name VARCHAR(100) NOT NULL UNIQUE,
> 	
> 	-- 该字段我们定义为非必传，即 String? 类型而非 String 类型，因此我们需要提供默认值
>   `desc` VARCHAR(100) DEFAULT(""),
> 	
> 	-- 该字段我们定义为非必传，即 Double? 类型而非 Double 类型，因此我们需要提供默认值
> 	price DOUBLE NOT NULL
> );
> ```

###### ✅ 2.1 创建表

> 在 Navicat Data Modeler 里，创建表时本身没有一个可勾选的“IF NOT EXISTS”开关，因为 Navicat Data Modeler 的职责更偏向表结构设计工具，而不是直接执行 SQL 的工具，所以如果需要“IF NOT EXISTS”的话，可以在生成 SQL 语句后，我们手动加上去。但实际上这一般都发生在初始创建表阶段，一般不会已存在表，所以不管也没关系
>
> 如果实在在意又不想手动修改 SQL 语句的话，可以让 Navicat Data Modeler 生成“创建表前先删除表的 SQL 语句”，从而避免已存在

![image-20260108162133968](01-数据库和表/img/image-20260108162133968.png)

***

![image-20260109102440609](01-数据库和表/img/image-20260109102440609.png)

###### ✅ 2.2 命名表

![image-20260108162925710](01-数据库和表/img/image-20260108162925710.png)

***

![image-20260109085003925](01-数据库和表/img/image-20260109085003925.png)

###### ✅ 2.3 给表添加字段

![image-20260108163415468](01-数据库和表/img/image-20260108163415468.png)

***

![image-20260108164854116](01-数据库和表/img/image-20260108164854116.png)

***

![image-20260109091847872](01-数据库和表/img/image-20260109091847872.png)

***

![image-20260109092016393](01-数据库和表/img/image-20260109092016393.png)

***

![image-20260109092427234](01-数据库和表/img/image-20260109092427234.png)

![image-20260109094830408](01-数据库和表/img/image-20260109094830408.png)

***

![image-20260109092544165](01-数据库和表/img/image-20260109092544165.png)

***

![image-20260109092645104](01-数据库和表/img/image-20260109092645104.png)

###### ✅ 2.4 设计完成后

![image-20260109095406053](01-数据库和表/img/image-20260109095406053.png)

###### ✅ 2.5 导出 SQL 语句

![image-20260109100642679](01-数据库和表/img/image-20260109100642679.png)

***

![image-20260109100805656](01-数据库和表/img/image-20260109100805656.png)

## ✅ 三、用 Navicat Premium 为数据库创建表

![image-20260109101805297](01-数据库和表/img/image-20260109101805297.png)

***

![image-20260109101925172](01-数据库和表/img/image-20260109101925172.png)

***

![image-20260109102325704](01-数据库和表/img/image-20260109102325704.png)

## ✅ 四、用 Navicat Premium 为表生成测试数据

![image-20260109103029868](01-数据库和表/img/image-20260109103029868.png)

***

![image-20260109103250733](01-数据库和表/img/image-20260109103250733.png)

***

![image-20260109104503748](01-数据库和表/img/image-20260109104503748.png)

## ✅ 五、一对一表结构和一对多表结构的设计

> 一对一表结构和一对多表结构的唯一区别就是：外键是否 UNIQUE，其它都一样。一对一表结构的外键必须得是 UNIQUE，否则就变成一对多表结构了
>
> 这里以一对多表结构为例，通过 SQL 语句手动创建表时是这样：先创建做为主表的歌手表，再创建做为从表的歌曲表
>
> ```mysql
> CREATE TABLE IF NOT EXISTS singer (
>   id BIGINT PRIMARY KEY AUTO_INCREMENT,
>   name VARCHAR(100) NOT NULL,
>   sex VARCHAR(100) DEFAULT('')
> );
> ```
>
> ```mysql
> CREATE TABLE IF NOT EXISTS song (
>   id BIGINT PRIMARY KEY AUTO_INCREMENT,
>   name VARCHAR(100) NOT NULL,
>   cover VARCHAR(100) DEFAULT(''),
> 	
>   -- 外键字段，必须与 t_singer.id 类型一致
>   -- 一对一表结构的外键必须得是 UNIQUE，否则就变成一对多表结构了：singer_id BIGINT UNIQUE,
>   singer_id BIGINT,
>   -- 在 CREATE 语句的最后添加一个外键约束，含义为：
>   -- 当前表中的外键 singer_id，引用的是 singer 表中的 id
>   -- ON UPDATE 和 ON DELETE 是指当我们修改或删除 singer.id 时，song 应该做出什么反应，默认情况下这个值是 RESTRICT —— 即如果某个字段被外键关联着、那么在修改或删除这个字段时直接报错、也就是说不允许删除或修改；我们通常会手动设置为 CASCADE —— 即允许修改或删除这个字段、并且如果是修改这个字段那就跟随修改另外一张表里的数据、如果是删除这个字段那就跟随删除另外一张表里的数据
>   FOREIGN KEY (singer_id) REFERENCES singer(id) ON UPDATE CASCADE ON DELETE CASCADE
> );
> ```

#### ✅ 1、先创建好两张表

![image-20260109134820403](01-数据库和表/img/image-20260109134820403.png)

#### ✅ 2、添加外键

![image-20260109134933355](01-数据库和表/img/image-20260109134933355.png)

***

![image-20260109135230738](01-数据库和表/img/image-20260109135230738.png)

***

![image-20260109135449143](01-数据库和表/img/image-20260109135449143.png)

***

![image-20260109141722603](01-数据库和表/img/image-20260109141722603.png)

## ✅ 六、多对多表结构的设计

> 通过 SQL 语句手动创建表时是这样：先创建做为主表的歌手表和歌曲表，再创建做为从表的中间表
>
> ```mysql
> CREATE TABLE IF NOT EXISTS singer (
>   id BIGINT PRIMARY KEY AUTO_INCREMENT,
>   name VARCHAR(100) NOT NULL,
>   sex VARCHAR(100) DEFAULT('')
> );
> ```
>
> ```mysql
> CREATE TABLE IF NOT EXISTS song (
>   id BIGINT PRIMARY KEY AUTO_INCREMENT,
>   name VARCHAR(100) NOT NULL,
>   cover VARCHAR(100) DEFAULT('')
> );
> ```
>
> ```mysql
> CREATE TABLE IF NOT EXISTS singer_song (
>   id BIGINT PRIMARY KEY AUTO_INCREMENT,
> 	
> 	-- 外键字段，必须与 singer.id 类型一致
> 	singer_id BIGINT,
> 	-- 外键字段，必须与 song.id 类型一致
>   song_id BIGINT,
> 	-- 在 CREATE 语句的最后添加一个外键约束，含义为：
>   -- 当前表中的外键 singer_id，引用的是 singer 表中的 id
>   -- ON UPDATE 和 ON DELETE 是指当我们修改或删除 singer.id 时，singer_song 应该做出什么反应，默认情况下这个值是 RESTRICT —— 即如果某个字段被外键关联着、那么在修改或删除这个字段时直接报错、也就是说不允许删除或修改；我们通常会手动设置为 CASCADE —— 即允许修改或删除这个字段、并且如果是修改这个字段那就跟随修改另外一张表里的数据、如果是删除这个字段那就跟随删除另外一张表里的数据
> 	FOREIGN KEY (singer_id) REFERENCES singer(id) ON UPDATE CASCADE ON DELETE CASCADE,
>   FOREIGN KEY (song_id) REFERENCES song(id) ON UPDATE CASCADE ON DELETE CASCADE
> );
> ```

#### ✅ 1、先创建好三张表

![image-20260109141443794](01-数据库和表/img/image-20260109141443794.png)

#### ✅ 2、添加外键

![image-20260109141208539](01-数据库和表/img/image-20260109141208539.png)

***

![image-20260109141118576](01-数据库和表/img/image-20260109141118576.png)