## 一、跨域是什么

要想知道跨域是什么，就得先知道浏览器的同源策略是什么`（注意跨域只发生在使用浏览器时，因为只有浏览器才有同源策略，App 开发里请求接口是没有跨域一说的）`

浏览器的同源策略是指两个资源的 URL 必须同时满足**协议相同 + 主机 IP 地址相同 + 端口号相同**，那么这两个资源才是同源的，否则这两个资源就不是同源的，而只有同源的资源才能互相访问，非同源的资源互相访问时就会发生跨域

- 协议相同：比如 `http` 和 `https`
- 主机 IP 地址相同：比如 `118.25.70.197` 和 `118.25.70.198`
- 端口号相同：比如 `80` 和 `8080`

举个会发生跨域的例子，实际开发中现在都是前后端分离了，前端项目打包后一般都是部署到专门的静态资源服务器上，而后端项目一般都是部署到专门的 API 服务器上，比如我们通过 http://118.25.70.197:80 请求到了前端项目的主页 index.html，进而加载到了前端项目的其它静态资源 css、js 等，而 js 代码里又请求了 http://118.25.70.197:8000/moment/getMomentList?pageSize=10&pageIndex=0 接口，那 js 代码里的这个接口请求就会报跨域问题，因为两个资源的端口号不同

```shell
Access to fetch at 'http://118.25.70.197:8000/moment/getMomentList?pageSize=10&pageIndex=0' from origin 'http://118.25.70.197:80' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
```

## 二、为什么会产生跨域

跨域是因为浏览器的同源策略导致的，而浏览器之所以搞同源策略，是出于安全考虑`（注意跨域只发生在使用浏览器时，因为只有浏览器才有同源策略，App 开发里请求接口是没有跨域一说的）`

比如说用户通过 http://118.25.70.197:80 请求到了前端项目的主页 index.html，进而加载到了前端项目的其它静态资源 css、js 等，本来 js 代码里是要去请求我们自己服务器上 http://118.25.70.197:8000/moment/getMomentList?pageSize=10&pageIndex=0 接口的，但是黑客在 js 代码注入了一些他们的代码，转而让 js 代码去请求他们服务器上的东西去了，此时如果没有同源策略的话，js 代码是能够成功访问到黑客服务器上的东西的，比如虚假的支付页面收集用户的支付信息等，而一旦有了同源策略，就算 js 代码被注入了，js 代码访问了黑客的服务器，但肯定会报跨域问题而导致无法成功访问黑客服务器上的东西的，也就保护了用户的数据安全

当然同源策略在保护用户数据安全的同时，也导致 js 代码本来想正常访问我们自己服务器上的接口时也无法正常访问了，这是同源策略带来的副作用，但是我们只要处理一下就可以正常访问

## 三、模拟出跨域

#### 后端

开发过程中，我们一般都是通过“node ./src/main.js”或“nodemon ./src/main.js”来运行 node 项目的，其实这就是在本机启动了一个本地 koa 服务器或 express 服务器，也就是说 node 项目里接口的源就是“http:127.0.0.1:8000”，我们可以认为后端接口是部署在“http:127.0.0.1:8000”这个源的

#### 前端

开发过程中，我们一般都是通过 live server 来打开 web 原生项目的，一般都是通过“npm run serve”来打开 vue 项目的。当我们通过 live server 来打开 web 原生项目时，live server 插件其实会在本机启动一个本地服务器并监听 5500 端口，也就是说 web 原生项目的源就是“http:127.0.0.1:5500”，我们可以认为 web 原生项目是部署在“http:127.0.0.1:5500”这个源的。当我们通过“npm run serve”来打开 vue 项目时，VueCLI 会使用 webpack-dev-server 在本机启动一个本地服务器并监听 8080 端口，也就是说 vue 项目的源就是“http:127.0.0.1:8080”，我们可以认为 vue 项目是部署在“http:127.0.0.1:8080”这个源的

#### 跨域

因此开发过程中，如果 web 原生项目里或 vue 项目里访问了后端接口，那就必然会遇到跨域问题，因为它们的源不同。所以去把 server-demo 和 client-demo 都跑起来，就能看到跨域问题了

## 四、怎么处理跨域

处理跨域的常见方案：

* 方案一：把静态资源和 API 部署在同一个源下（虽然是根治，但是极少使用，都是分开部署）
* `方案二：服务端开启 CORS，支持跨域资源共享（后端开发者来解决，解决方式简单快速、前端啥也不需要干）`
* `方案三：node 代理服务器转发（前端开发者来解决，前端项目开发阶段用这个）`
* `方案四：nginx 代理服务器转发（前端开发者来解决，前端项目发布阶段用这个）`

**实际开发中，以服务端处理为主。**

#### 1、服务端开启 CORS

###### CORS 是什么

CORS 全称是 Cross-Origin Resource Sharing，翻译过来是跨域资源共享。它是一种基于 http header 的机制，该机制允许把一些静态资源服务器的源添加进白名单，白名单里的源可以跨域访问当前服务器上的接口

###### 服务端开启 CORS 怎么实现

只需要全局配置所有的 http 请求返回相应的响应头即可（如 Access-Control-Allow-Origin），告诉浏览器当前服务器上的接口可以被白名单里静态资源服务器的源跨域访问

```js
// 跨域处理配置
@Configuration
public class CorsConfig implements WebMvcConfigurer {
    @Autowired
    CorsProperties corsProperties;

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        // /**：代表对所有的请求进行跨域处理
        registry.addMapping("/**")
                // *：代表允许任意静态资源服务器的源跨域访问我们服务器上的接口
                // 不过实际开发中我们一般就是填写自己静态资源服务器的源
                .allowedOrigins(corsProperties.getAllowedOrigins())
                // *：代表允许任意请求方法（GET、POST、HEAD、PUT、DELETE、CONNECT、OPTIONS、TRACE、PATCH）跨域访问
                .allowedMethods("*")
                // *：代表允许前端携带任意请求头
                .allowedHeaders("*")
                // true：代表允许前端跨域携带 Cookie
                .allowCredentials(true);
    }
}
```

#### 2、node 代理服务器转发

###### 代理服务器转发是什么

既然跨域发生在静态资源服务器上的 js 访问 API 服务器时，那我们完全可以引入一个第三者——一台代理服务器——来解决跨域，让静态资源服务器上的 js 去访问这台代理服务器，然后代理服务器再去访问 API 服务器，前面说过`跨域只发生在使用浏览器时，因为只有浏览器有同源策略`，所以代理服务器去访问 API 服务器时绝对没有跨域问题的，不过你可能会问了“那静态资源服务器上的 js 去访问代理服务器难道不会跨域吗？”答案是会，所以`我们还需要解决一下静态资源服务器上的 js 去访问代理服务器的跨域问题`，`开发阶段`具体怎么解决看下边

###### node 代理服务器转发怎么实现

开发过程中，我们一般都是通过“npm run serve”来打开 vue 项目的，当我们通过“npm run serve”来打开 vue 项目时，VueCLI 会使用 webpack-dev-server 在本机启动一个本地服务器并监听 8080 端口，也就是说 vue 项目的源就是“http:127.0.0.1:8080”，我们可以认为 vue 项目是部署在“http:127.0.0.1:8080”这个源的

而 webpack 其实已经帮我们考虑好了`开发阶段`解决 vue 项目的跨域问题，`我们只需要在 vue.config.js 文件里做一下代理服务器的配置 + vue 项目里发起请求时通过 node 代理地址发起请求即可`，只要做了这个配置，当我们通过“npm run serve”来打开 vue 项目时，VueCLI 使用 webpack-dev-server 在本机启动的这个本地 node 服务器就不仅仅是一个静态资源服务器了，它与此同时还是一个代理服务器，这也是为什么这样做就可以解决上面提到的`静态资源服务器上的 js 去访问代理服务器的跨域问题`，因为它俩现在完全就是一台服务器且监听着相同的端口，类似于我们之前提到的方案一：把静态资源和 API 部署在同一个源下

- 首先在 vue.config.js 中配置代理服务器

```js
// ====== vue.config.js，可以去替换试试 ======

const { defineConfig } = require("@vue/cli-service");
module.exports = defineConfig({
  transpileDependencies: true,
  devServer: {
    proxy: {
      // 静态资源服务器上的 js 发起以 /api 开头的请求时会请求到代理服务器
      "/api": {
        // 代理服务器要转发到的目标服务器地址——即 api 服务器的真实地址
        target: "http://118.25.70.197:8000",
        // 重写路径，去掉 /api 前缀
        // 静态资源服务器上的 js 发起的请求是以 /api 开头的，但 api 服务器上并没有这个前缀，所以需要重写路径，例如：/api/users 会被重写为 /users
        pathRewrite: {
          "^/api": "",
        },
        // 改变请求源
        // api 服务器可能配置了只接收来自静态服务器 ip 地址的请求，所以当它接收到来自代理服务器的请求时，可能会拒绝访问，所以我们要通过这个配置让 api 服务器认为代理服务器发出的请求就是静态服务器发出的请求
        changeOrigin: true,
      },
    },
  },
});
```

- 然后在发起请求的地方直接用 /api 开头的路径就可以了，同时也不要再加协议和 ip 地址

```js
// ====== App.vue，可以去替换试试 ======

<template>
  <button @click="handleClick">获取动态列表</button>
</template>

<script>
export default {
  name: 'App',
  methods: {
    handleClick() {
      // 开发阶段用 node 代理服务器，接口请求用 node 代理地址
      // 发布阶段用 nginx 代理服务器，接口请求用 nginx 代理地址
      const baseURL = process.env.NODE_ENV === 'production'
        ? '/client-demo/api'
        : '/api';
      fetch(`${baseURL}/moment/getMomentList?pageSize=10&pageIndex=0`).then((res) => {
        return res.json();
      }).then((data) => {
        console.log("动态列表", data);
      });
    }
  }
}
</script>
```

#### 3、nginx 代理服务器转发

###### 代理服务器转发是什么

既然跨域发生在静态资源服务器上的 js 访问 API 服务器时，那我们完全可以引入一个第三者——一台代理服务器——来解决跨域，让静态资源服务器上的 js 去访问这台代理服务器，然后代理服务器再去访问 API 服务器，前面说过`跨域只发生在使用浏览器时，因为只有浏览器有同源策略`，所以代理服务器去访问 API 服务器时绝对没有跨域问题的，不过你可能会问了“那静态资源服务器上的 js 去访问代理服务器难道不会跨域吗？”答案是会，所以`我们还需要解决一下静态资源服务器上的 js 去访问代理服务器的跨域问题`，`发布阶段`具体怎么解决看下边

###### nginx 代理服务器转发怎么实现

`我们只需要在 nginx.conf 文件里做一下代理服务器的配置 + vue 项目里发起请求时通过 nginx 代理地址发起请求即可`。这样做就可以解决上面提到的`静态资源服务器上的 js 去访问代理服务器的跨域问题`，因为 nginx 作为云服务器上的一个软件，它现在充当了两个角色：监听 80 端口返回 vue 项目的静态资源、所以我们可以把它视作就是静态资源服务器；监听 80 端口转发请求，所以我们可以把它视作就是代理服务器，也就是说静态资源服务器和代理服务器现在完全就是一台服务器且监听着相同的端口，类似于我们之前提到的方案一：把静态资源和 API 部署在同一个源下

- 首先在 vue.config.js 中配置代理服务器

```js
// ====== nginx.conf，可以去替换试试 ======

location /client-demo {
    alias /root/client-demo/;
    index index.html;
    try_files $uri $uri/ /fun-car/index.html;
}

# 专门处理API请求，api 后面的 / 不能少
location /client-demo/api/ {
    # nginx 服务器在监听 80 端口所有 vue 项目的访问，可以充当代理服务器的功能
    # 当收到匹配 /client-demo/api 的请求时，都转发到 api 服务器
    # 后面的 / 不能少
    proxy_pass http://118.25.70.197:8000/;
}
```

- 然后在发起请求的地方直接用 /client-demo/api 开头的路径就可以了，同时也不要再加协议和 ip 地址

```js
// ====== App.vue，可以去替换试试 ======

<template>
  <button @click="handleClick">获取动态列表</button>
</template>

<script>
export default {
  name: 'App',
  methods: {
    handleClick() {
      // 开发阶段用 node 代理服务器，接口请求用 node 代理地址
      // 发布阶段用 nginx 代理服务器，接口请求用 nginx 代理地址
      const baseURL = process.env.NODE_ENV === 'production'
        ? '/client-demo/api'
        : '/api';
      fetch(`${baseURL}/moment/getMomentList?pageSize=10&pageIndex=0`).then((res) => {
        return res.json();
      }).then((data) => {
        console.log("动态列表", data);
      });
    }
  }
}
</script>
```
