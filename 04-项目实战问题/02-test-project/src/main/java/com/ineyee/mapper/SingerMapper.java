package com.ineyee.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.ineyee.pojo.po.Singer;

// 1、在 mapper 目录下创建一个 XxxMapper 的空接口类即可
// 需要让我们的接口类继承自 MyBatis-Plus 的 BaseMapper 接口，这样一来当前 mapper 层就自动拥有了众多接口方法和 mapper 实现
// 泛型需要指定一下对应的 po 类
//
// 2、一张表对应的 dao，我们一般会把它定义成接口，然后为这个接口编写多个实现类
// 因为实际开发中我们很可能需要根据实际情况切换访问数据库的方案，比如 JDBC、Hibernate、MyBatis 等，这种面向接口编程的方式方便切换方案
//
// 3、用户模块接口的数据层
// 数据层（mapper）的职责就是直接与数据库打交道，即：
//     * 调用数据层的“增删改” API + 传给这些 API 一个和 po 直接相关的参数，你就可以获取到影响的数据条数
//     * 调用数据层的“查” API + 传给这些 API 一个和 po 直接相关的参数，你就可以获取到原始模型 po
// 换句话说：
//     * 数据层只需要对自己负责就行，负责的体现就是干好创建 SQL 语句、执行 SQL 语句、获取执行结果、返回执行结果给业务层即可
//     * 对上，数据层要绝对相信业务层，相信的体现就是直接拿着参数去做访问数据库，而不再纠结于参数会不会出问题，要绝对相信经过业务层校验后的参数是肯定没问题的
//     * 其它的数据层就不用关心了，至于执行结果失败了怎样、成功了怎样，那是业务层拿到结果后该干的事
// 实践经验：
//     * 执行成功时，总是把执行成功的结果返回（虽然增删改操作执行成功的结果意义不大、查操作执行成功的结果意义才大），业务层用不用执行成功的结果由它自己决定
//     * 执行失败时，这里不需要 try-catch 执行失败的异常，往上层抛、抛到业务层
public interface SingerMapper extends BaseMapper<Singer> {
}
