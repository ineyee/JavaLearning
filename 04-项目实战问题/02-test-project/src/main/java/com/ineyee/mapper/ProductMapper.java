package com.ineyee.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.ineyee.pojo.po.Product;

// 1、在 mapper 目录下创建一个 XxxMapper 的空接口类即可
// 只要让接口类继承自 BaseMapper，那么该 mapper 层就自动拥有了众多接口方法和 mapper 实现
// 泛型指定一下对应的 po 类
//
// 2、一张表对应的 mapper，我们一般会把它定义成接口，然后为这个接口编写多个实现类
// 因为实际开发中我们很可能需要根据实际情况切换访问数据库的方案，比如 JDBC、Hibernate、MyBatis 等，这种面向接口编程的方式方便切换方案
//
// 3、数据层
// 数据层（mapper）的职责就是直接与数据库打交道，即：
//     * 调用数据层的“增删改” API + 传给这些 API 一个和 po 直接相关的参数，你就可以获取到影响的数据条数
//     * 调用数据层的“查” API + 传给这些 API 一个和 po 直接相关的参数，你就可以获取到原始模型 po
// 换句话说：
//     * 数据层只需要对自己负责就行，负责的体现就是干好创建 SQL 语句、执行 SQL 语句、获取执行结果、返回执行结果给业务层即可
//     * 对上，数据层要绝对相信业务层，相信的体现就是直接拿着参数去做访问数据库，而不再纠结于参数会不会出问题，要绝对相信经过业务层校验后的参数是肯定没问题的
//     * 其它的数据层就不用关心了，至于执行结果失败了怎样、成功了怎样，那是业务层拿到结果后该干的事
// 实践经验：
//     * 执行成功时，总是把执行成功的结果返回（虽然增删改操作执行成功的结果意义不大、查操作执行成功的结果意义才大），业务层用不用执行成功的结果由它自己决定
//     * 执行失败时，这里不需要 try-catch 执行失败的异常，往上层抛、抛到业务层（数据层的异常都是系统异常，最终会抛到全局异常处理那里进行统一处理）
public interface ProductMapper extends BaseMapper<Product> {

}
