前面我们学习的一套是 Spring 2.x 时期的 XML + 注解混合开发方式，XML + 注解混合开发方式存在以下问题：

* XML 不具备类型安全，XML 文件里就算拼错名字也不会编译报错
* XML 文件里无法根据某些条件动态决定 bean



所以 Spring 3.x 时期引入了纯注解开发方式来解决上述问题，此时就是`全部都用注解，完全可以不存在 Spring 的 XML 配置文件了`。

## 一、添加依赖

纯注解开发方式下，我们依然需要添加各个相关依赖

```xml
<!-- Spring 相关的依赖 -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>7.0.0-RC1</version>
</dependency>
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjrt</artifactId>
    <version>1.9.25</version>
</dependency>
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.25</version>
</dependency>

<!-- MyBatis 相关的依赖 -->
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>3.5.19</version>
</dependency>
<dependency>
    <groupId>com.mysql</groupId>
    <artifactId>mysql-connector-j</artifactId>
    <version>9.4.0</version>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.2.27</version>
</dependency>
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper</artifactId>
    <version>6.1.1</version>
</dependency>

<!-- Spring 整合 MyBatis 特有的依赖 -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>7.0.0-RC1</version>
</dependency>
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis-spring</artifactId>
    <version>3.0.0</version>
</dependency>

<!-- 提供 Servlet 相关的接口和类 -->
<dependency>
    <groupId>jakarta.servlet</groupId>
    <artifactId>jakarta.servlet-api</artifactId>
    <version>6.1.0</version>
    <scope>provided</scope>
</dependency>

<!-- JSON 字符串和 Map 互转 -->
<dependency>
    <groupId>com.google.code.gson</groupId>
    <artifactId>gson</artifactId>
    <version>2.13.2</version>
</dependency>

<!-- 日志打印 -->
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>1.5.19</version>
</dependency>

<!-- 单元测试 -->
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <version>5.8.2</version>
    <scope>test</scope>
</dependency>
```

## 二、创建 Spring 配置类和创建 applicationContext

XML + 注解混合开发方式下，我们依然需要创建 Spring 配置文件，也依然是通过 Spring 配置文件来创建 applicationContext。

纯注解开发方式下，没有 XML 文件了，但是我们需要创建一个 Spring 配置类，然后通过这个 Spring 配置类来创建 applicationContext：

* 在 cfg 目录下创建一个名字叫做 AppConfig.java 的配置类，专门用来配置 Spring 相关的东西。然后给这个类添加一个 @Configuration 注解，有了这个注解，这个配置类就完全跟之前的 applicationContext.xml 配置文件一样的功能了，并且 @Configuration 也是一个 @Component，这就意味着 Spring 也会自动创建它的对象并放入 IoC 容器里

```java
// AppConfig.java

@Configuration
public class AppConfig { }
```

* 在应用启动时通过 Spring 配置类创建一次 applicationContext

```java
// App.java

public class App {
    public static void main(String[] args) {
        // 通过 Spring 配置类来创建 applicationContext
        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
    }
}
```

## 三、纯注解实现 IoC

#### 基本实现

> 现在我们就知道了三种 Spring 创建对象的方式，<bean> 标签法、@Component 注解法、@Bean 注解法
>
> 同时我们也会发现 @Component 注解法只适用于那些我们自己定义的 Java 类，因为只有这些 Java 类我们才能在源码里编写注解，而系统的类或三方库的类我们现在可以通过 <bean> 标签法或 @Bean 注解法来搞，因为我们不能在人家的源码里编写注解
>
> 换句话说，@Component 注解法只适用于我们自己定义的 Java 类，而 <bean> 标签法和 @Bean 注解法是万能的。建议：我们自己定义的 Java 类优先使用 @Component 注解法，这样可以为配置类减负，系统的类或三方库的类再使用 @Bean 注解法

XML + 注解混合开发方式下，我们要想让 Spring 框架自动创建一个对象并放到 IoC 容器里，要做两件事：

* 在 Spring 配置文件里通过 context:component-scan 标签告诉 Spring 框架哪个包里的类是通过注解实现 IoC 的，Spring 框架就会扫描这个包里所有的类来自动创建对象并放到 IoC 容器里

  ```xml
  <!--
      通过 context:component-scan 标签告诉 Spring 框架哪个包里的类是通过注解实现 IoC 的
      Spring 框架就会扫描这个包里所有有注解的类来自动创建对象并放到 IoC 容器里
  -->
  <context:component-scan base-package="com.ineyee._01_IoC"/>
  ```

* 在`我们自己定义的 Java 类`里写一个 @Component 或 @Controller 或 @Service 或 @Repository 注解就可以了（@Controller、@Service、@Repository 和 @Component 的功能一模一样，只是为了见名知意名字不同），该对象默认的 beanId 就是它所属类名的第一个字母变成小写，当然我们也可以通过 value 属性来自定义 beanId（value 属性名可以省略不写，直接写值）

  ```java
  // User.java
  
  @Component
  public class User { }
  ```

  ```java
  // UserServlet.java
  
  @Controller
  public class UserServlet { }
  ```

  ```java
  // UserServiceImpl.java
  
  @Service(value = "userService")
  public class UserServiceImpl implements UserService { }
  ```

  ```java
  // UserDaoImpl.java
  
  @Repository("userDao")
  public class UserDaoImpl implements UserDao { }
  ```

纯注解开发方式下，我们要想让 Spring 框架自动创建一个对象并放到 IoC 容器里，也要做两件事：

* 在 Spring 配置类里通过 @ComponentScan 注解告诉 Spring 框架哪个包里的类是通过注解实现 IoC 的，Spring 框架就会扫描这个包里所有的类来自动创建对象并放到 IoC 容器里（@ComponentScan 注解就是之前 context:component-scan 标签的功能）

  ```java
  @Configuration
  @ComponentScan("com.ineyee._01_IoC")
  public class AppConfig { }
  ```

* 因为配置类类似之前的配置文件，所以我们只要在 Spring 配置类里定义一个一个的方法并给这些方法添加 @Bean 注解（就像之前在配置文件里写一个一个的 bean 标签一样），Spring 框架就会自动创建一个对象并放到 IoC 容器里，该对象默认的 beanId 就是方法名，当然我们也可以通过 value 属性来自定义 beanId（value 属性名可以省略不写，直接写值）

  ```java
  @Configuration
  @ComponentScan("com.ineyee._01_IoC")
  public class AppConfig {
      @Bean("user")
      public User user() {
          return new User();
      }
  }
  ```

* 当然我们依然可以在`我们自己定义的 Java 类`里写 @Component 或 @Controller 或 @Service 或 @Repository 注解，这样可以为 AppConfig.java 减负

  ```java
  // User.java
  
  @Component
  public class User { }
  ```

  ```java
  // UserServlet.java
  
  @Controller
  public class UserServlet { }
  ```

  ```java
  // UserServiceImpl.java
  
  @Service(value = "userService")
  public class UserServiceImpl implements UserService { }
  ```

  ```java
  // UserDaoImpl.java
  
  @Repository("userDao")
  public class UserDaoImpl implements UserDao { }
  ```

#### 补充：@Scope 注解

@Scope 注解就是之前 <bean> 标签里 scope 属性的功能，用来决定“在同一个 IoC 容器里 + 通过同一个 beanId 获取到的对象是不是只有一份”，默认值是 singleton，还有另外一个值是 prototype。

```java
@Configuration
@ComponentScan("com.ineyee._01_IoC")
public class AppConfig {
    @Bean("user")
    @Scope("singleton")
    //@Scope("prototype")
    public User user() {
        return new User();
    }
}
```

## 四、纯注解实现 DI

#### 基本实现

> 现在我们就知道了三种 Spring 依赖注入的方式，<property> 标签法、@Autowired 和 @Value 注解法、@Bean 注解的方法手动设置法
>
> 同时我们也会发现 @Autowired、@Value 注解法只适用于那些我们自己定义的 Java 类 + 基本数据类型、BigDecimal、字符串、自定义对象类型的属性，因为只有这些 Java 类我们才能在源码里编写注解，并且当我们自定义的类有集合类型的属性也建议这个类所有的属性都用标签法或 @Bean 注解的方法手动设置法来注入；而系统的类或三方库的类我们现在可以通过 <property> 标签法或 @Bean 注解的方法手动设置法来搞，因为我们不能在人家的源码里编写注解
>
> 换句话说，@Autowired、@Value 注解法只适用于我们自己定义的 Java 类 + 基本数据类型、BigDecimal、字符串、自定义对象类型的属性，而 <property> 标签法或 @Bean 注解的方法手动设置法是万能的。建议：我们自己定义的 Java 类优先使用 @Autowired、@Value 注解法，这样可以为配置类减负，我们自定义的类里有集合类型的属性或系统的类或三方库的类再使用 @Bean 注解的方法手动设置法

实际开发中，一般都是通过 setter 方法注入，所以这里就不演示通过构造方法注入了。

XML + 注解混合开发方式下，我们要实现依赖注入，直接在`我们自己定义的 Java 类`里的 setter 方法上写一个 @Value 或 @Autowired 注解就可以了，其中：

* 当属性的数据类型为基本数据类型、BigDecimal、字符串时，用 @Value（@Value 注入的值总是一个字符串，会自动转换成目标数据类型）
* 当属性的数据类型为自定义对象类型，用 @Autowired（@Autowired 是根据 setter 方法参数的数据类型注入的，而不是参数的名字，也就是说 @Autowired 会在 IoC 容器里查找所有符合该数据类型的对象，如果只找到一个对象那就能成功注入，如果找到多个对象那就得配合下面的 @Qualifier 注解来使用了）
* 当某个属性的数据类型为集合类型时，建议这个类所有的属性都用 @Bean 注解的方法手动设置法来注入

纯注解开发模式下，依然是这么做。

```java
// Dog.java

@Component
public class Dog {
    private String name;

    @Value("旺财")
    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Dog{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

```java
// Person.java

@Component
public class Person {
    // 基本数据类型
    private Boolean isPartyMember;
    private Integer age;
    private Double height;

    @Value("false")
    public void setPartyMember(Boolean partyMember) {
        isPartyMember = partyMember;
    }

    @Value("18")
    public void setAge(Integer age) {
        this.age = age;
    }

    @Value("1.88")
    public void setHeight(Double height) {
        this.height = height;
    }

    // BigDecimal
    private BigDecimal salary;

    @Value("666666.66")
    public void setSalary(BigDecimal salary) {
        this.salary = salary;
    }

    // 字符串
    private String name;

    @Value("张三")
    public void setName(String name) {
        this.name = name;
    }

    // 自定义对象类型
    private Dog dog;

    @Autowired
    public void setDog(Dog dog) {
        this.dog = dog;
    }

    @Override
    public String toString() {
        return "Person{" +
                "isPartyMember=" + isPartyMember +
                ", age=" + age +
                ", height=" + height +
                ", salary=" + salary +
                ", name='" + name + '\'' +
                ", dog=" + dog +
                '}';
    }
}
```

只不过`如果要给系统的类或三方库的类注入依赖，那就得为它一对一新增一个专门的 Spring 子配置类（当然我们也可以直接在 AppConfig.java 主配置类里搞，但弄子配置类就是为了给主配置类减负，如果搞了子配置类，也不需要在 AppConfig.java 这个主配置类里引入子配置类，因为大家都是 @Configuration、都在 IoC 容器里即可），然后通过 @Bean 注解的方法来创建对象，然后自定义属性 + @Value、@Autowired 间接注入值，然后通过 setter 方法把注入的值手动赋值`：

```java
// ThirdPartyClass.java

public class ThirdPartyClass {
    private Integer type;

    public void setType(Integer type) {
        this.type = type;
    }

    @Override
    public String toString() {
        return "ThirdPartyClass{" +
                "type=" + type +
                '}';
    }
}
```

```java
// ThirdPartyClassConfig.java

@Configuration
public class ThirdPartyClassConfig {
    // 自定义属性，间接注入值
    @Value("22")
    Integer type;

    // 通过 @Bean 注解的方法来创建对象
    @Bean
    public ThirdPartyClass thirdPartyClass() {
        ThirdPartyClass thirdPartyClass = new ThirdPartyClass();
        // 通过 setter 方法把注入的值手动赋值
        thirdPartyClass.setType(type);
        return thirdPartyClass;
    }
}
```

#### 补充：@Qualifier 注解

上面我们已经提到“@Autowired 是根据 setter 方法参数的数据类型注入的，而不是参数的名字”，那么如果 IoC 容器里有多个 UserService 类的实现，比如：

```java
public interface UserService { }

@Service(value = "userService")
public class UserServiceImpl implements UserService { }

@Service(value = "userService1")
public class UserServiceImpl1 implements UserService { }
```

此时如果仅靠 @Autowired 类型注入就会报错：NoUniqueBeanDefinitionException，因为 Spring 不知道我们到底要用哪一个实现类的对象：

```java
@Controller
public class UserServlet {
    private UserService userService;

    @Autowired()
    public void setUserService(UserService userService) {
        this.userService = userService;
    }
}
```

这时就得用 @Qualifier 注解来告诉 Spring，我们明确想要用 beanId 为 xxx 的那一个bean 对象：

```java
@Controller
public class UserServlet {
    private UserService userService;

    @Autowired
    @Qualifier("userService1")
    public void setUserService(UserService userService) {
        this.userService = userService;
    }
}
```

## 五、纯注解实现创建过程比较复杂的对象的 IoC 与 DI

#### 基本实现

XML + 注解混合开发方式下，我们依然得用 Spring 自带的 FactoryBean 法创建一个 FactoryBean 类，但是不是在 Spring 配置文件里做 FactoryBean 对象的创建与依赖注入，而是直接在 FactoryBean 类里做。

纯注解开发模式下，依然是这么做。

```java
// ConnectionFactoryBean.java

// FactoryBean 类，类似于前面的工厂类
// 必须实现 Spring 自带的 FactoryBean 接口，并且指定我们要创建的 Bean 类型
// 这个类是用来创建 connection 对象的，而不是用来创建它自己的对象的，所以 beanId 直接叫 connection 即可，不能要默认的 connectionFactoryBean
@Component("connection")
public class ConnectionFactoryBean implements FactoryBean<Connection> {
    private String driverClassName;
    private String url;
    private String username;
    private String password;

    @Value("com.mysql.cj.jdbc.Driver")
    public void setDriverClassName(String driverClassName) {
        this.driverClassName = driverClassName;
    }

    @Value("jdbc:mysql://localhost:3306/db_hello_mysql?serverTimezone=UTC")
    public void setUrl(String url) {
        this.url = url;
    }

    @Value("root")
    public void setUsername(String username) {
        this.username = username;
    }

    @Value("mysqlroot")
    public void setPassword(String password) {
        this.password = password;
    }

    // 这个方法类似于前面的静态方法或实例方法
    @Override
    public Connection getObject() throws Exception {
        // 第一步：将厂商的数据库驱动 Driver 注册到 JDBC 的驱动管理者 DriverManager
        Class.forName(driverClassName);
        // 第二步：利用 DriverManager 创建一个数据库连接对象 connection
        Connection connection = DriverManager.getConnection(url, username, password);

        return connection;
    }

    // 这个方法固定返回我们要创建的 Bean 类型
    @Override
    public Class<?> getObjectType() {
        return Connection.class;
    }
}
```

#### 补充：@PropertySource 注解

前面的演示里，我们是把数据库相关配置的值直接写死在 Java 类里注入的，但是实际开发中我们一般都是把数据库相关配置的值写在独立的配置文件里，然后在 Java 类里引入独立的配置文件，这样一来我们如果想改一下数据库相关配置的值，直接改独立的配置文件即可， Java 类根本不用动。

@PropertySource 注解就是之前 context:property-placeholder 标签的功能，用来引入其它配置文件，只不过 context:property-placeholder 标签是写在 Spring 配置文件里，@PropertySource 注解是写在我们自己定义的 Java 类里。

* `database.properties`

```properties
# key 用小驼峰，value 不用加 ""
# key-value 的分隔符是 = 或 : ，推荐使用 = ，= 的左右两边不要加空格

driverClassName=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/db_hello_mysql?serverTimezone=UTC
username=root
password=mysqlroot
```

* `ConnectionFactoryBean.java`

```java
// FactoryBean 类，类似于前面的工厂类
// 必须实现 Spring 自带的 FactoryBean 接口，并且指定我们要创建的 Bean 类型
// 这个类是用来创建 connection 对象的，而不是用来创建它自己的对象的，所以 beanId 直接叫 connection 即可，不能要默认的 connectionFactoryBean
@Component("connection")
@PropertySource("database.properties")
public class ConnectionFactoryBean implements FactoryBean<Connection> {
    private String driverClassName;
    private String url;
    private String username;
    private String password;

    @Value("${driverClassName}")
    public void setDriverClassName(String driverClassName) {
        this.driverClassName = driverClassName;
    }

    @Value("${url}")
    public void setUrl(String url) {
        this.url = url;
    }

    @Value("${username}")
    public void setUsername(String username) {
        this.username = username;
    }

    @Value("${password}")
    public void setPassword(String password) {
        this.password = password;
    }

    // 这个方法类似于前面的静态方法或实例方法
    @Override
    public Connection getObject() throws Exception {
        // 第一步：将厂商的数据库驱动 Driver 注册到 JDBC 的驱动管理者 DriverManager
        Class.forName(driverClassName);
        // 第二步：利用 DriverManager 创建一个数据库连接对象 connection
        Connection connection = DriverManager.getConnection(url, username, password);

        return connection;
    }

    // 这个方法固定返回我们要创建的 Bean 类型
    @Override
    public Class<?> getObjectType() {
        return Connection.class;
    }
}
```

## 六、纯注解实现 AOP

#### 基本实现

纯 XML 开发方式下，我们需要创建一个实现了 MethodInterceptor 接口的 Interceptor 类，在这个类里写好`附加代码`，然后在 Spring 配置文件里配置`切面`、`切入点`、`advisor`。

XML + 注解混合开发方式下，我们要想实现 AOP，要做五步，纯注解开发方式下，也是一样的五步，只是第一步稍有不同：

* 第一步：不是在 Spring 配置文件里写个 aop:aspectj-autoproxy 标签，而是在 Spring 配置类里写个 @EnableAspectJAutoProxy 注解，两者是一样的功能

* 第二步：自定义一个类，用 @Aspect 注解标识一下这个类是个`切面类`（@Aspect 注解就是之前 aop:config 标签的功能，用来表示一个切面，现在一个切面类就是一个切面），再用 @Component 注解让 Spring 自动创建这个类的对象并放到 IoC 容器里
* 第三步：然后定义一个空方法，在这个空方法上面用 @Pointcut 注解来配置给哪些类的哪些方法附加代码（@Pointcut 注解就是之前 aop:pointcut 标签的功能，用来表示一个`切入点`）
* 第四步：然后在这个类里定义一个一个的方法（方法名随便、参数必须是 ProceedingJoinPoint、返回值也必须是 Object），这一个一个的方法就是之前一个一个的 Interceptor 类里的 invoke 方法，这一个一个的方法就是业务层代理的方法，我们就是把`附加代码`写在这一个一个的方法里
* 第五步：然后在这一个一个的方法上面用 @Around 注解把切入点和附加代码给整合起来（@Aspect 注解就是之前 aop:advisor 标签的功能，用来把切入点和附加代码给整合起来）

```java
@Configuration
@ComponentScan("com.ineyee._04_aop.basicuse")
@EnableAspectJAutoProxy
public class AppConfig {
}
```

```java
@Aspect
@Component
public class DefaultAspect {
    @Pointcut("execution(* com.ineyee._04_aop.basicuse.service..*.*(..))")
    public void pointcut() {
    }

    // 我们可以认为这个方法就是业务层代理的方法
    // 我们只需要专心考虑附加代码怎么写就可以了
    @Around("pointcut()")
    public Object log(ProceedingJoinPoint point) throws Throwable {
        // 业务层代理调用业务层的代码（相当于中介跟房东对接）
        Object result = point.proceed();

        // 业务层的附加代码都抽取到业务层代理中来了
        System.out.println("假设这里是【日志存储】的附加代码");

        return result;
    }
}
```

* 控制器层的代码一点都不用动，加个 @Controller 和 @Autowired 注解即可

```java
@Controller
public class UserServlet {
    // 控制器层表面还是持有业务层，实际却是持有业务层代理（本质原因是我们在 afterInit 生命周期方法里把创建业务层对象“篡改”成了创建业务层代理对象）
    private UserService userService;

    @Autowired
    public void setUserService(UserService userService) {
        this.userService = userService;
    }

    public Boolean login(String username, String password) {
        // 控制器层表面还是在直接调用业务层的代码，实际却是在调用业务层代理的代码（相当于租客跟中介对接）
        return userService.login(username, password);
    }
}
```

* 业务层只写业务代码，加个 @Service 注解即可

```java
public interface UserService {
    Boolean login(String username, String password);
}

@Service("userService")
public class UserServiceImpl implements UserService {
    @Override
    public Boolean login(String username, String password) {
        // 业务层只写业务代码
        System.out.println("假设这里是【业务规则校验】的业务代码，去数据库里查询用户和密码是否匹配");
        System.out.println("假设这里是【调用数据层 API】的业务代码，调用数据层的 login 方法");

        return true;
    }
}
```

#### 补充：AOP 的实际应用场景——事务

纯 XML 开发方式下，我们是直接在 Spring 配置文件里配置`数据源`、`事务管理器`、`附加代码`、`切面`就实现了事务管理。

XML + 注解混合开发方式下，我们要想实现事务管理，要做四步，纯注解开发方式下，也是一样的四步，只是第一步稍有不同：

* 第一步：不是在 Spring 配置文件里配置数据源，而是在 Spring 子配置类配置`数据源`

  ```java
  // 数据源，将会被事务管理器引用
  @Configuration
  // 开发环境和生产环境的数据库连接池及连接及数据库
  //     开发阶段，我们可以把默认环境设置为开发环境，从而访问测试数据库
  //     生产阶段，我们可以把默认环境设置为生产环境，从而访问正式数据库
  @PropertySource("database-dev.properties")
  public class DatabaseConfig {
      // 自定义属性，间接注入值
      @Value("${driverClassName}")
      private String driverClassName;
      @Value("${url}")
      private String url;
      @Value("${username}")
      private String username;
      @Value("${password}")
      private String password;
      @Value("${initialSize}")
      private int initialSize;
      @Value("${maxActive}")
      private int maxActive;
  
      // 通过 @Bean 注解的方法来创建对象
      @Bean
      public DataSource dataSource() {
          DruidDataSource dataSource = new DruidDataSource();
          // 通过 setter 方法把注入的值手动赋值
          dataSource.setDriverClassName(driverClassName);
          dataSource.setUrl(url);
          dataSource.setUsername(username);
          dataSource.setPassword(password);
          dataSource.setInitialSize(initialSize);
          dataSource.setMaxActive(maxActive);
          return dataSource;
      }
  }
  ```

* 第二步：不是在 Spring 配置文件里配置事务管理器，而是在 Spring 子配置类配置`事务管理器`

* 第三步：不是在 Spring 配置文件里新增配置一个`事务管理的注解驱动`，而是在 Spring 子配置类里写一个注解

  ```java
  // 事务管理器
  @Configuration
  // 这个注解是“事务管理的注解驱动”的功能
  @EnableTransactionManagement
  public class TxConfig {
      // 自定义属性，间接注入值
      private DataSource dataSource;
  
      @Autowired
      public void setDataSource(DataSource dataSource) {
          this.dataSource = dataSource;
      }
  
      // 通过 @Bean 注解的方法来创建对象
      @Bean
      public DataSourceTransactionManager txMgr() {
          DataSourceTransactionManager txMgr = new DataSourceTransactionManager();
          // 通过 setter 方法把注入的值手动赋值
          txMgr.setDataSource(dataSource);
          return txMgr;
      }
  }
  ```

* 第四步：然后我们想给哪个业务增加事务管理的代码，就直接在这个业务类里加上一个 @Transactional 注解就完事了，这样一来这个业务类里所有的方法都会自动加上事务管理的代码，当然我们也可以只在某一个方法上加上一个 @Transactional 注解

  ```java
  @Service("moneyService")
  @Transactional
  public class MoneyServiceImpl implements MoneyService {
      MoneyDao moneyDao;
  
      @Autowired
      public void setMoneyDao(MoneyDao moneyDao) {
          this.moneyDao = moneyDao;
      }
  
      @Override
      @Transactional(rollbackFor = Exception.class)
      public void transfer(Integer fromUserId, Integer toUserId, Double money) {
          // 这里会自动切入开启事务的代码
          // fromUserId 扣钱
          moneyDao.update(fromUserId, -money);
  
          // 模拟业务执行过程中出现异常
          System.out.println(10 / 0);
  
          // toUserId 加钱
          moneyDao.update(toUserId, money);
  
          // 成功后，这里会自动切入会提交事务的代码
          // 失败后，这里会自动切入会回滚事务的代码
      }
  }
  ```

## 七、纯注解 Spring 整合 MyBatis

之前是纯 XML Spring 整合 MyBatis，现在是纯注解 Spring 整合 MyBatis，其实其它部分都不用动，只需要把 applicationContext.xml 替换成纯注解的实现即可，我们一块一块替换：

* 数据源部分

  ```xml
  <!-- 1 -->
  <context:property-placeholder location="database-dev.properties"/>
  <bean id="devDataSource" class="com.alibaba.druid.pool.DruidDataSource">
      <property name="driverClassName" value="${driverClassName}"/>
      <property name="url" value="${url}"/>
      <property name="username" value="${username}"/>
      <property name="password" value="${password}"/>
      <property name="initialSize" value="${initialSize}"/>
      <property name="maxActive" value="${maxActive}"/>
  </bean>
  
  <!-- 2 -->
  <context:property-placeholder location="database-prod.properties"/>
  <bean id="prodDataSource" class="com.alibaba.druid.pool.DruidDataSource">
      <property name="driverClassName" value="${driverClassName}"/>
      <property name="url" value="${url}"/>
      <property name="username" value="${username}"/>
      <property name="password" value="${password}"/>
      <property name="initialSize" value="${initialSize}"/>
      <property name="maxActive" value="${maxActive}"/>
  </bean>
  ```

  ```java
  @Configuration
  @PropertySource("mybatis.properties")
  public class MyBatisConfig {
      // =========== 数据源，将会被 sqlSessionFactory 引用 ==============
      // 开发环境和生产环境的数据库连接池及连接及数据库
      //     开发阶段，我们可以把默认环境设置为开发环境，从而访问测试数据库
      //     生产阶段，我们可以把默认环境设置为生产环境，从而访问正式数据库
  
      // 自定义属性，间接注入值
      @Value("${dev.driverClassName}")
      private String devDriverClassName;
      @Value("${dev.url}")
      private String devUrl;
      @Value("${dev.username}")
      private String devUsername;
      @Value("${dev.password}")
      private String devPassword;
      @Value("dev.${dev.initialSize}")
      private int devInitialSize;
      @Value("${dev.maxActive}")
      private int devMaxActive;
  
      @Value("${prod.driverClassName}")
      private String prodDriverClassName;
      @Value("${prod.url}")
      private String prodUrl;
      @Value("${prod.username}")
      private String prodUsername;
      @Value("${prod.password}")
      private String prodPassword;
      @Value("dev.${prod.initialSize}")
      private int prodInitialSize;
      @Value("${prod.maxActive}")
      private int prodMaxActive;
  
      // 通过 @Bean 注解的方法来创建对象
      @Bean
      public DataSource devDataSource() {
          DruidDataSource dataSource = new DruidDataSource();
          // 通过 setter 方法把注入的值手动赋值
          dataSource.setDriverClassName(devDriverClassName);
          dataSource.setUrl(devUrl);
          dataSource.setUsername(devUsername);
          dataSource.setPassword(devPassword);
          dataSource.setInitialSize(devInitialSize);
          dataSource.setMaxActive(devMaxActive);
          return dataSource;
      }
  
      @Bean
      public DataSource prodDataSource() {
          DruidDataSource dataSource = new DruidDataSource();
          dataSource.setDriverClassName(prodDriverClassName);
          dataSource.setUrl(prodUrl);
          dataSource.setUsername(prodUsername);
          dataSource.setPassword(prodPassword);
          dataSource.setInitialSize(prodInitialSize);
          dataSource.setMaxActive(prodMaxActive);
          return dataSource;
      }
  }
  ```

* sqlSessionFactory 对象部分

  ```xml
  <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
    	<!-- 1 -->
      <property name="configuration">
          <bean class="org.apache.ibatis.session.Configuration">
              <property name="mapUnderscoreToCamelCase" value="true"/>
          </bean>
      </property>
  
      <!-- 2 -->
      <property name="typeAliasesPackage" value="com.ineyee._05_combinemybatis.domain"/>
      <property name="typeAliases">
          <list>
              <value>com.ineyee._05_combinemybatis.domain.User</value>
          </list>
      </property>
  
    	<!-- 3 -->
      <property name="plugins">
          <list>
              <bean class="com.github.pagehelper.PageInterceptor">
                  <property name="properties">
                      <props>
                          <prop key="reasonable">true</prop>
                      </props>
                  </property>
              </bean>
          </list>
      </property>
  
    	<!-- 4 -->
      <property name="dataSource" ref="devDataSource"/>
  
    	<!-- 5 -->
      <property name="mapperLocations">
          <list>
              <value>mappers/*.xml</value>
          </list>
      </property>
  </bean>
  ```

  ```java
  @Configuration
  @PropertySource("mybatis.properties")
  public class MyBatisConfig {
      // =========== 数据源，将会被 sqlSessionFactory 引用 ==============
  
      // 自定义属性，间接注入值
      @Value("${ssf.typeAliasesPackage}")
      private String typeAliasesPackage;
      @Value("${ssf.mapperLocations}")
      private String mapperLocations;
  
      // 通过 @Bean 注解的方法来创建对象
      // 这里看似是返回 SqlSessionFactoryBean 对象，但实际上返回的是 SqlSessionFactoryBean 对象.getObject() 方法创建的 sqlSessionFactory 对象
      // 所以方法名我们直接就叫 sqlSessionFactory 了，而不是 sqlSessionFactoryBean
      @Bean
      public SqlSessionFactoryBean sqlSessionFactory() throws IOException {
          SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
          // 通过 setter 方法把注入的值手动赋值
  
          // 1
          org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration();
          configuration.setMapUnderscoreToCamelCase(true);
          sqlSessionFactoryBean.setConfiguration(configuration);
  
          // 2
          sqlSessionFactoryBean.setTypeAliasesPackage(typeAliasesPackage);
  
          // 3
          com.github.pagehelper.PageInterceptor pageInterceptor = new com.github.pagehelper.PageInterceptor();
          Properties properties = new Properties();
          properties.setProperty("reasonable", "true");
          pageInterceptor.setProperties(properties);
          sqlSessionFactoryBean.setPlugins(new Interceptor[]{pageInterceptor});
  
          // 4
          sqlSessionFactoryBean.setDataSource(devDataSource());
  
          // 5
          sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(mapperLocations));
  
          return sqlSessionFactoryBean;
      }
  }
  ```

*  mapper 扫描器部分

  ```xml
  <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
      <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/>
      <property name="basePackage" value="com.ineyee._05_combinemybatis.dao"/>
  </bean>
  ```

  ```java
  @Configuration
  @PropertySource("mybatis.properties")
  @MapperScan("${ms.mapperScan}") // 现在写个注解就可以了
  public class MyBatisConfig { }
  ```
