## ✅ 一、日志处理发展史

刚开始的时候，只有日志框架，没有日志门面接口，比如只有 JUL 和 Log4j 日志框架，项目里是直接使用日志框架的 API，所以一旦需要替换日志框架，就有很多地方得修改，非常麻烦。因此后来就出现了日志门面接口，比如 SLF4J 和 Log4j2，项目里是使用日志门面接口的 API，至于下层用的到底是什么日志框架，可以自由切换。`现在项目里一般都是用 SLF4J + Logback 或 Log4j2。`

* ~~System.out.println~~
  * 最简单
  * 但是能做的事非常有限

* ~~JUL（Java Util Logging）~~
  * JDK 自带的日志框架
  * 但是 API 不完善，很少人使用
* ~~Log4j（Log For Java）~~
  * Apache 组织推出的日志框架
  * 但是 1.x 版本存在性能问题，已于 2015 年停止维护
* SLF4J（Simple Logging Facade For Java，酸辣粉）
  * Log4j 作者（Apache 组织里的一个人）推出的日志门面接口
  * 开发者面向该门面接口做开发，至于下层用的到底是什么日志框架，可以自由切换
* Logback
  * Log4j 作者（Apache 组织里的一个人）推出的日志框架，实现了 SLF4J 门面接口
  * 比 Log4j 性能高很多，SpringBoot 项目默认使用的日志框架
* Log4j2
  * Apache 组织推出的日志门面接口和日志框架，它既是接口也是实现
  * Log4j 的重大升级改进版，甚至改进了 Logback 的一些问题

## ✅ 二、为什么使用日志系统

开发环境：

* debug 打印变量值、函数调用到控制台，以便验证代码执行结果、追踪代码执行流程

生产环境：

* info 持久化关键配置的启动与关闭、关键业务流程的关键节点到日志文件，以便靠少量关键信息就能排查业务问题、分析用户行为偏好
* warn 持久化不影响功能正常运行的业务异常到日志文件，以便优化系统
* error 持久化影响功能正常运行的崩溃到日志文件，以便定位崩溃

## 三、怎么使用日志系统

#### ✅ 1、日志系统级别

日志系统从低到高一般有 6 个级别：TRACE < DEBUG < INFO < WARNING < ERROR < FATAL，设置为什么级别就只会输出当前级别及以上级别的日志，OFF 是关闭日志。不过实际开发中我们一般把 TRACE 并入 DEBUG、FATAL 并入 ERROR，只使用 4 个级别：

| 级别           | 用途                                                         | 问自己                                             | 生产环境 |
| -------------- | ------------------------------------------------------------ | -------------------------------------------------- | -------- |
| DEBUG - 调试   | 帮助开发者理解代码执行结果和代码执行过程，强调打印`代码`相关的东西<br />可以很详细，不用担心日志量 | 只想看看变量值、看看函数有没有调用？<br />用 DEBUG | 关闭     |
| INFO - 信息    | 记录系统正在做什么，强调记录`业务`相关的东西<br />应该精简，只记录关键配置的启动与关闭、关键业务流程的关键节点 | 想记录业务流程？<br />用 INFO                      | 开启     |
| WARNING - 警告 | 记录不影响功能正常运行的问题，开发者需关注但不一定需处理<br />一般就是抛业务异常的地方 | 出问题了但程序能继续？<br />用 WARN                | 开启     |
| ERROR - 错误   | 记录影响功能正常运行的崩溃，开发者需立即处理<br />一般就是抛系统异常的地方，必须记录异常堆栈 | 出问题了且需要人工介入？<br />用 ERROR             | 开启     |

```java
public class LoginService {
  private static final Logger log = LoggerFactory.getLogger(LoginService.class);

  /**
   * 用户登录主流程
   */
  public LoginResult login(String username, String password) {
    // traceId（追踪ID/链路ID）是一个唯一标识符，用来关联同一个请求在系统中产生的所有日志，并发请求时更容易过滤出相关联的日志
    String traceId = UUID.randomUUID().toString();

    // ====== INFO：关键业务入口 ======
    log.info("[{}] 用户登录请求, username: {}", traceId, username);
    
    try {
      // ====== DEBUG：开发时看到参数细节 ======
      log.debug("[{}] 参数校验开始, username: {}, passwordLength: {}",
                traceId, username, password != null ? password.length() : 0);
      if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
        throw new LoginException("用户名或密码不能为空");
      }
      // ====== DEBUG：验证通过的确认 ======
      log.debug("[{}] 参数校验通过", traceId);

      // ====== INFO：关键业务完成 ======
      log.info("[{}] 用户登录成功, userId: {}, username: {}", traceId, user.getId(), username);
      return LoginResult.success(token);
    } catch (LoginException e) {
      // ====== WARN：用户输入错误（参数有效性校验异常、非系统问题） ======
      log.warn("[{}] 参数为空, username: {}", traceId, username);
      return LoginResult.fail(e.getMessage());
    } catch (Exception e) {
      // ====== ERROR：未预期的系统异常 ======
      log.error("[{}] 登录流程异常, username: {}", traceId, username, e);
      return LoginResult.fail("系统异常，请稍后重试");
    }
  }
}
```

#### ✅ 2、SLF4J + Logback

> 直接创建一个 SpringBoot 项目

###### ✅ 2.1 添加 logger 的依赖

> SpringBoot 项目的 spring-boot-starter-web 会默认添加 Logback 依赖，而 Logback 依赖会默认添加 SLF4J 依赖，所以我们不需要再手动添加

###### ✅ 2.2 创建 logger 的配置文件

> 名字固定为 logback-spring.xml

```xml
<?xml version="1.0" encoding="utf-8" ?>
<!--
    scan="true" scanPeriod="30 seconds"
    让 logback 每隔 30 秒重新扫描一下配置文件，并应用最新的配置文件
-->
<configuration scan="true" scanPeriod="30 seconds">
    <!--
        使用 property 标签定义一个变量，抽取日志文件所在目录
            线上 Linux 系统，我们输出到 /var/log/${AppName}/app.log 文件中
    -->
    <property name="LOG_FILE_HOME" value="/var/log/slf4j_logback"/>

    <!-- 定义一个输出目标：控制台 -->
    <appender name="consoleAppender" class="ch.qos.logback.core.ConsoleAppender">
        <!-- 控制台的输出格式与编码方式 -->
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <!--
                输出格式
                    %highlight：彩色输出
                    %d：时间
                    %p：日志级别
                    %t：线程
                    %c：消息是在哪个类里输出的
                    %m：消息
                    %n：换行
            -->
            <pattern>%highlight([%d{yyyy-MM-dd HH:mm:ss.SSS}] [%-5p] [%t] [%c]: %m%n)</pattern>
            <!-- 编码方式：UTF-8 -->
            <charset>UTF-8</charset>
        </encoder>
    </appender>

    <!-- 把 rollingFileAppender 搞成异步的，这样一来把日志写入到文件的操作就会变成异步的 -->
    <appender name="asyncRollingFileAppender" class="ch.qos.logback.classic.AsyncAppender">
        <!-- 定义一个输出目标：文件 -->
        <appender name="rollingFileAppender" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <!-- 文件的输出格式与编码方式 -->
            <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
                <!--
                    输出格式
                        %highlight：彩色输出，文件里面没有彩色
                        %d：时间
                        %p：日志级别
                        %t：线程
                        %c：消息是在哪个类里输出的
                        %m：消息
                        %n：换行
                -->
                <pattern>[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%-5p] [%t] [%c]: %m%n</pattern>
                <!-- 编码方式：UTF-8 -->
                <charset>UTF-8</charset>
            </encoder>
            <!-- 文件的路径 -->
            <file>${LOG_FILE_HOME}/app.log</file>
            <!--
                文件的滚动策略，基于文件大小和时间
                    每隔一天，自动生成新文件，以当天日期命名
                    同一天内单个文件最大 100M，超过 100M 时自动生成新文件，以当天日期命名
                    所有文件总大小最大 10G，超过 10G 时自动清理最早的文件
                    自动清理超过 30 天的文件

                /var/log/${AppName}/
                ├─app.log                 <- 当前
                ├─app.log.2026.01.04.0    <- 今天的第 1 个文件（100M）
                ├─app.log.2026.01.04.1    <- 今天的第 2 个文件（100M）
                ├─app.log.2026.01.03.0    <- 昨天的文件
            -->
            <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
                <!-- 自动生成的新文件名，时间精确到天，支持压缩文件（可节省 70%~90% 的存储空间） -->
                <fileNamePattern>${LOG_FILE_HOME}/app.log.%d{yyyy-MM-dd}.%i.gz</fileNamePattern>
                <!-- 单个文件最大大小 -->
                <maxFileSize>100MB</maxFileSize>
                <!-- 所有文件总大小 -->
                <totalSizeCap>10GB</totalSizeCap>
                <!-- 最多保留多少天，这里的单位取决于 fileNamePattern 里的时间精确到什么单位 -->
                <maxHistory>30</maxHistory>
            </rollingPolicy>
        </appender>
    </appender>

    <!--
        开发环境的 logger 配置
        application.yml 里的 active: - dev | - prd 会自动匹配这里的环境
    -->
    <springProfile name="dev">
        <!--
            项目里所有 logger 的配置都写在这个 root 标签里
                日志级别为：DEBUG
                是否给父 logger 传递日志事件：false
                输出目标为：控制台
        -->
        <root level="DEBUG" additivity="false">
            <appender-ref ref="consoleAppender"/>
        </root>

        <!--
            如果我们想给某个包里的 logger 单独配置，可以新增一个 logger 标签
            controller 包里所有 logger 的配置都写在这个 logger 标签里，会覆盖 root 标签里的配置
                日志级别为：DEBUG
                是否给父 logger 传递日志事件：false（默认 true，会把日志事件传递给 rootLogger，导致打印多遍，所以总应设置为 false）
                输出目标为：控制台
        -->
        <logger name="com.ineyee.controller" level="DEBUG" additivity="false">
            <appender-ref ref="consoleAppender"/>
        </logger>
        <!--
            如果我们想给某个类里的 logger 单独配置，可以新增一个 logger 标签
            TestService 类里 logger 的配置都写在这个 logger 标签里，会覆盖 root 标签里的配置
                日志级别为：WARN
                是否给父 logger 传递日志事件：false（默认 true，会把日志事件传递给 rootLogger，导致打印多遍，所以总应设置为 false）
                输出目标为：控制台
        -->
        <logger name="com.ineyee.service.TestService" level="WARN" additivity="false">
            <appender-ref ref="consoleAppender"/>
        </logger>
    </springProfile>

    <!--
        生产环境的 logger 配置
        application.yml 里的 active: - dev | - prd 会自动匹配这里的环境
    -->
    <springProfile name="prd">
        <!--
            项目里所有 logger 的配置都写在这个 root 标签里
                日志级别为：INFO
                是否给父 logger 传递日志事件：false
                输出目标为：文件
        -->
        <root level="INFO" additivity="false">
            <appender-ref ref="asyncRollingFileAppender"/>
        </root>
    </springProfile>
</configuration>
```

###### ✅ 2.3 编写 Java 代码，输出日志

> 实际开发中，建议为每个类写一个独立的 logger，而不是整个项目只写一个全局的 logger。因为“整个项目只写一个全局的 logger”无法区分日志来源于哪个包哪个类哪行代码、无法按包或按类进行日志级别控制

```java
package com.ineyee.controller;

import com.ineyee.service.TestService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TestController {
    @Autowired
    private TestService testService;

    // LoggerFactory.getLogger 的时候把当前类传进去，就能在日志中看到当前类名
    private static final Logger logger = LoggerFactory.getLogger(TestController.class);

    @GetMapping("/test")
    public String test() {
        logger.debug("我是调试_DEBUG");
        logger.info("我是信息_INFO");
        logger.warn("我是警告_WARN");
        logger.error("我是错误_ERROR");

        testService.test();

        return "test";
    }
}
```

```java
package com.ineyee.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

// 并且如果我们的项目里使用了 lombok
// 那么只要用 @Slf4j 注解修饰一下类，lombok 就会自动创建一个变量名为 log 的静态 logger 对象
// 这样一来我们就不用在每个类里手动创建 logger 对象了，直接输出日志即可
@Slf4j
@Service
public class TestService {
    public void test() {
        log.debug("我是调试_DEBUG");
        log.info("我是信息_INFO");
        log.warn("我是警告_WARN");
        log.error("我是错误_ERROR");
    }
}
```

#### ✅ 3、Log4j2

> 直接创建一个 SpringBoot 项目

###### ✅ 3.1 添加 logger 的依赖

> Log4j2 既是门面接口也是日志框架

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
  <!-- 排除 SpringBoot 项目默认的 logback 依赖 -->
  <exclusions>
    <exclusion>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-logging</artifactId>
    </exclusion>
  </exclusions>
</dependency>
<!-- 添加 log4j2 依赖 -->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-log4j2</artifactId>
</dependency>
```

###### ✅ 3.2 创建 logger 的配置文件

> 名字固定为 log4j2-spring.xml

```xml
<?xml version="1.0" encoding="utf-8" ?>
<!-- log4j2 的配置文件只能使用大驼峰，不能使用小驼峰 -->
<!--
    monitorInterval="30"
    让 log4j2 每隔 30 秒重新扫描一下配置文件，并应用最新的配置文件
-->
<Configuration monitorInterval="30">
    <!--
        使用 Property 标签定义变量，抽取日志文件所在目录
            测试 macOS 系统，我们输出到 /Users/yiyi/Desktop/log/app.log 文件中
            线上 Linux 系统，我们输出到 /var/log/${AppName}/app.log 文件中
    -->
    <Properties>
        <SpringProfile name="dev">
            <Property name="LOG_FILE_HOME">/Users/yiyi/Desktop/log</Property>
        </SpringProfile>
        <SpringProfile name="prd">
            <Property name="LOG_FILE_HOME">/var/log/log4j2</Property>
        </SpringProfile>

        <!--
            控制台输出格式
                %highlight：彩色输出
                %d：时间
                %p：日志级别
                %t：线程
                %c：消息是在哪个类里输出的
                %m：消息
                %n：换行
        -->
        <Property name="CONSOLE_PATTERN">%highlight{[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%-5p] [%t] [%c]: %m%n}</Property>
        <!--
            文件输出格式
        -->
        <Property name="FILE_PATTERN">[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%-5p] [%t] [%c]: %m%n</Property>
    </Properties>

    <Appenders>
        <!-- 定义一个输出目标：控制台 -->
        <Console name="consoleAppender">
            <!-- 控制台的输出格式与编码方式 -->
            <PatternLayout pattern="${CONSOLE_PATTERN}" charset="UTF-8"/>
        </Console>

        <!-- 定义一个输出目标：文件 -->
        <RollingFile name="rollingFileAppender" fileName="${LOG_FILE_HOME}/app.log"
                     filePattern="${LOG_FILE_HOME}/app.log.%d{yyyy-MM-dd}.%i.gz">
            <!-- 文件的输出格式与编码方式 -->
            <PatternLayout pattern="${FILE_PATTERN}" charset="UTF-8"/>
            <!--
                文件的滚动策略，基于文件大小和时间
                    每隔一天，自动生成新文件，以当天日期命名
                    同一天内单个文件最大 100M，超过 100M 时自动生成新文件，以当天日期命名
                    所有文件总大小最大 10G，超过 10G 时自动清理最早的文件
                    自动清理超过 30 天的文件

                /var/log/${AppName}/
                ├─app.log                 <- 当前
                ├─app.log.2026.01.06.0.gz <- 今天的第 1 个文件（100M）
                ├─app.log.2026.01.06.1.gz <- 今天的第 2 个文件（100M）
                ├─app.log.2026.01.05.0.gz <- 昨天的文件
            -->
            <Policies>
                <!-- 基于时间的滚动策略：每天生成新文件 -->
                <TimeBasedTriggeringPolicy/>
                <!-- 基于文件大小的滚动策略：单个文件最大 100M -->
                <SizeBasedTriggeringPolicy size="100MB"/>
            </Policies>
            <!-- 文件索引，最多 100 个文件 -->
            <DefaultRolloverStrategy max="100">
                <!-- 删除策略：删除超过 30 天的文件，或者所有文件总大小超过 10G 时删除最早的文件 -->
                <Delete basePath="${LOG_FILE_HOME}" maxDepth="1">
                    <IfFileName glob="app.log.*.gz"/>
                    <IfAny>
                        <!-- 删除超过 30 天的文件 -->
                        <IfLastModified age="30d"/>
                        <!-- 所有文件总大小超过 10G 时删除最早的文件 -->
                        <IfAccumulatedFileSize exceeds="10GB"/>
                    </IfAny>
                </Delete>
            </DefaultRolloverStrategy>
        </RollingFile>

        <!-- 把 rollingFileAppender 搞成异步的，这样一来把日志写入到文件的操作就会变成异步的 -->
        <Async name="asyncRollingFileAppender">
            <AppenderRef ref="rollingFileAppender"/>
        </Async>
    </Appenders>

    <Loggers>
        <!--
            开发环境的 logger 配置
            application.yml 里的 active: - dev | - prd 会自动匹配这里的环境
        -->
        <SpringProfile name="dev">
            <!--
                项目里所有 logger 的配置都写在这个 Root 标签里
                    日志级别为：DEBUG
                    输出目标为：控制台
            -->
            <Root level="DEBUG">
                <AppenderRef ref="consoleAppender"/>
            </Root>

            <!--
                如果我们想给某个包里的 logger 单独配置，可以新增一个 Logger 标签
                controller 包里所有 logger 的配置都写在这个 Logger 标签里，会覆盖 Root 标签里的配置
                    日志级别为：DEBUG
                    是否给父 logger 传递日志事件：false（默认 true，会把日志事件传递给 rootLogger，导致打印多遍，所以总应设置为 false）
                    输出目标为：控制台
            -->
            <Logger name="com.ineyee.controller" level="DEBUG" additivity="false">
                <AppenderRef ref="consoleAppender"/>
            </Logger>
            <!--
                如果我们想给某个类里的 logger 单独配置，可以新增一个 Logger 标签
                TestService 类里 logger 的配置都写在这个 Logger 标签里，会覆盖 Root 标签里的配置
                    日志级别为：WARN
                    是否给父 logger 传递日志事件：false（默认 true，会把日志事件传递给 rootLogger，导致打印多遍，所以总应设置为 false）
                    输出目标为：控制台
            -->
            <Logger name="com.ineyee.service.TestService" level="WARN" additivity="false">
                <AppenderRef ref="consoleAppender"/>
            </Logger>
        </SpringProfile>

        <!--
            生产环境的 logger 配置
            application.yml 里的 active: - dev | - prd 会自动匹配这里的环境
        -->
        <SpringProfile name="prd">
            <Root level="INFO">
                <AppenderRef ref="asyncRollingFileAppender"/>
            </Root>
        </SpringProfile>
    </Loggers>
</Configuration>
```

###### ✅ 3.3 编写 Java 代码，输出日志

> 实际开发中，建议为每个类写一个独立的 logger，而不是整个项目只写一个全局的 logger。因为“整个项目只写一个全局的 logger”无法区分日志来源于哪个包哪个类哪行代码、无法按包或按类进行日志级别控制

```java
package com.ineyee.controller;

import com.ineyee.service.TestService;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TestController {
    @Autowired
    private TestService testService;

    // LogManager.getLogger 的时候把当前类传进去，就能在日志中看到当前类名
    private static final Logger log =
            LogManager.getLogger(TestController.class);

    @GetMapping("/test")
    public String test() {
        log.debug("我是调试_DEBUG");
        log.info("我是信息_INFO");
        log.warn("我是警告_WARN");
        log.error("我是错误_ERROR");

        testService.test();

        return "test";
    }
}
```

```java
package com.ineyee.service;

import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;

// 并且如果我们的项目里使用了 lombok
// 那么只要用 @Log4j2 注解修饰一下类，lombok 就会自动创建一个变量名为 log 的静态 logger 对象
// 这样一来我们就不用在每个类里手动创建 logger 对象了，直接输出日志即可
@Log4j2
@Service
public class TestService {
    public void test() {
        log.debug("我是调试_DEBUG");
        log.info("我是信息_INFO");
        log.warn("我是警告_WARN");
        log.error("我是错误_ERROR");
    }
}
```

