<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!-- 演示一对一关系 -->
<mapper namespace="dao.songDao1">
    <!-- 方式一：特殊 SQL 语句 + resultType -->
    <select id="list1" resultType="bean.SongBean1">
        -- 多表查询要用 JOIN
        SELECT
            -- 这里千万不能给表1的字段取别名，保持数据库表里的原始字段名即可，因为用了 resultType 的话，MyBatis 默认是把数据库里的原始字段和把下划线变成小驼峰后映射到 JavaBean 的属性
            -- t_song 的字段对应 FROM t_song，代表是从 t_song 里的查询
            t_song.id,
            t_song.name,
            t_song.cover,
            t_song.create_time,
            t_song.update_time,
            -- 这里一定要给表2的字段取别名，并且别名必须按下面的要求，MyBatis 才能自动封装成 singerBean1 对象
            -- singerBean1 必须是 songBean1 里对应对象的属性名，后面的属性名也必须是 singerBean1 里对应的属性名
            t_singer.id          AS `singerBean1.id`,
            t_singer.name        AS `singerBean1.name`,
            t_singer.sex         AS `singerBean1.sex`,
            t_singer.create_time AS `singerBean1.createTime`,
            t_singer.update_time AS `singerBean1.updateTime`
        -- t_song 是表1
        FROM t_song
                 -- t_singer 是表2，表1.外键 = 表2.主键
                 LEFT JOIN t_singer ON t_song.singer_id = t_singer.id;
    </select>

    <!-- 方式二（用得更多）：正常 SQL 语句 + resultMap -->
    <!--
        resultMap，专门用来处理数据库表字段和 Java Bean 属性之间的映射关系
            id 属性：当前 resultMap 的唯一标识，可以取名为 rm + 当前映射文件名，代表要处理 t_song 表到 SongBean 的映射
            type 属性：当前 resultMap 要映射成的 Java Bean 类型（SQL 语句里 FROM 表对应的 JavaBean）
        注意：一个 resultMap 可以被多个 SQL 语句所引用，比如 get 和 list 的映射其实是一样的，大家就可以共用一个 resultMap
    -->
    <resultMap id="rmSong1" type="bean.SongBean1">
        <!--
            一个 result 就代表一个数据库表字段到 Java Bean 属性的映射，这里映射的是上面 bean.SongBean1 的属性
                column 属性的值是数据库表字段名，如果我们的 SQL 语句里没取别名那就写数据库表里的原始字段名，如果取了别名那就写别名
                property 属性的值是 JavaBean 的属性名
        -->
        <result column="song_id" property="id"/>
        <result column="song_name" property="name"/>
        <result column="song_cover" property="cover"/>
        <result column="song_create_time" property="createTime"/>
        <result column="song_update_time" property="updateTime"/>

        <!--
            association 代表上面的 bean.SongBean1 对象内部只持有一个 bean.SingerBean1 对象（因为是一对一关系）
                property 属性：代表上面的 bean.SongBean1 对象通过 singerBean1 属性持有着 bean.SingerBean1 对象
                javaType 属性：代表上面的 bean.SongBean1 对象持有的对象类型是 bean.SingerBean1（SQL 语句里 JOIN 表对应的 JavaBean）
        -->
        <association property="singerBean1" javaType="bean.SingerBean1">
            <!--
                同样地，一个 result 就代表一个数据库表字段到 Java Bean 属性的映射，这里映射的是上面 bean.SingerBean1 的属性
                    column 属性的值是数据库表字段名，如果我们的 SQL 语句里没取别名那就写数据库表里的原始字段名，如果取了别名那就写别名
                    property 属性的值是 JavaBean 的属性名
            -->
            <result column="singer_id" property="id"/>
            <result column="singer_name" property="name"/>
            <result column="singer_sex" property="sex"/>
            <result column="singer_create_time" property="createTime"/>
            <result column="singer_update_time" property="updateTime"/>
        </association>
    </resultMap>
    <!-- 这里就不再直接写 resultType 属性了，而是通过 resultMap 属性来引用相应的 resultMap -->
    <select id="list2" resultMap="rmSong1">
        -- 多表查询要用 JOIN
        SELECT
            -- 这里是在给表1和表2的字段取别名，避免查询结果里的字段名冲突
            -- t_song 的字段对应 FROM t_song，代表是从 t_song 里的查询
            t_song.id            AS song_id,
            t_song.name          AS song_name,
            t_song.cover         AS song_cover,
            t_song.create_time   AS song_create_time,
            t_song.update_time   AS song_update_time,
            -- t_singer 的字段对应 LEFT JOIN t_singer，代表是从 t_singer 里的查询
            t_singer.id          AS singer_id,
            t_singer.name        AS singer_name,
            t_singer.sex         AS singer_sex,
            t_singer.create_time AS singer_create_time,
            t_singer.update_time AS singer_update_time
        -- t_song 是表1
        FROM t_song
                 -- t_singer 是表2，表1.外键 = 表2.主键
                 LEFT JOIN t_singer ON t_song.singer_id = t_singer.id;
    </select>

    <!-- t_song 表是从表，它里面有外键，所以除了存储 song 本身的数据之外，还得存储一个外键 -->
    <insert id="save" parameterType="bean.SongBean1">
        INSERT INTO t_song (name, cover, singer_id)
        -- 外界传进来一个 SongBean1 对象，所以参数名只要和 SongBean1 对象中的属性名一一对应，就能顺利匹配到参数值
        -- 存在对象嵌套时，直接使用嵌套对象及其属性即可，MyBatis 能自动去读取嵌套的 SingerBean1 对象及其属性
        VALUES (#{name}, #{cover}, #{singerBean1.id});

        -- 自动回填属性
        <selectKey order="AFTER" keyProperty="id,createTime,updateTime" resultType="bean.SongBean1">
            SELECT
            id AS id,
            create_time AS createTime,
            update_time AS updateTime
            FROM t_song
            WHERE id = LAST_INSERT_ID();
        </selectKey>
    </insert>
</mapper>