<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--
    namespace，当前文件的命名空间，可以理解为当前文件里所有 SQL 语句唯一标识的默认前缀，避免当前文件里 SQL 语句的唯一标识和别的文件里 SQL 语句的唯一标识重复
    TODO：一般命名为全类名 = dao + 某个模块具体的 Dao（因为这里就相当于是某个模块的数据层了）
-->
<mapper namespace="dao.UserDao">
    <!--
        select 标签里用来写“查”的 SQL 语句
            id：这条 SQL 语句的唯一标识，可以按照 dao 层方法的命名规范来命名
            parameterType：给 SQL 语句提供参数的入参真实类型，外界传进来时统一是基类 Object
            resultType：从数据库表里查询出来一条一条的数据，会自动转换成 UserBean 类型的对象
    -->
    <select id="get" parameterType="Integer" resultType="UserBean">
        -- 从数据库里读取数据时，建议 SQL 语句里显式写全要查询的所有字段，不要用 *
        SELECT id,
               name,
               age,
               height,
               email,
               create_time,
               update_time
        FROM t_user
        -- id 是参数名，因为外界只传进来一个参数且没有名字，所以这里参数名随便取什么都行，但是为了见名知意，这里取 id
        -- # {} 和 $ {} 都可以用来读取参数值，但是：
        --   # {} 类似于预处理 SQL 语句，更加安全高效，所以实际开发中用得多
        --   $ {} 类似于 SQL 语句，会直接把外界传进来的东西当成字符串替换掉形参，有 SQL 注入的风险，所以实际开发中除非就是需要直接替换 SQL 语句里的字符串，否则不要用
        WHERE id = #{id};
    </select>
    <select id="list" parameterType="Map" resultType="UserBean">
        SELECT id,
               name,
               age,
               height,
               email,
               create_time,
               update_time
        FROM t_user
        -- limit、offset 是参数名，因为外界传进来一个 Map，所以参数名只要和 Map 中的 key 一一对应，就能顺利匹配到参数值
        ORDER BY create_time DESC
            LIMIT #{limit}
        OFFSET #{offset};
    </select>


    <!-- insert 标签里用来写“增”的 SQL 语句 -->
    <insert id="save" parameterType="UserBean">
        -- 往数据库里插入数据时，建议 SQL 语句里显式写全表里的所有字段
        -- 这样外界传进来的 bean 如果全部属性都有值，那就完全匹配
        -- 如果有的可选属性没值，那 MyBatis 就会自动用 null 填充，最终数据库里会是该可选字段的默认值或 null
        INSERT INTO t_user (name,
        age,
        height,
        email)
        -- name、age、height、email 是参数名，因为外界传进来一个 bean，所以参数名只要和 bean 中的属性名一一对应，就能顺利匹配到参数值
        -- “# + {}”用来读取参数值
        VALUES (#{name},
        #{age},
        #{height},
        #{email});

        -- 外界不是传进来一个 bean 来保存嘛，实际开发中我们一般都是在插入成功后直接给客户端返回 bean 的 id 或完整 bean
        -- 这里 MyBatis 提供了一个自动回填的功能，可以在插入成功后自动把新插入数据的某些字段回填到传进来的 bean 对象中
        -- 这样外界就可以直接拿着传进来的那个 bean 对象返回给客户端了，就不用再去数据库查询一遍了
        -- order="AFTER"：代表在插入语句后执行回填
        -- keyProperty：要回填的属性名，即 bean 里的属性名（多个属性名之间用逗号隔开，注意不能有空格）
        -- resultType：bean 的类型
        <selectKey order="AFTER" keyProperty="id,createTime,updateTime" resultType="UserBean">
            SELECT
            -- 别名要跟 keyProperty 里的一致
            id AS id,
            create_time AS createTime,
            update_time AS updateTime
            FROM t_user
            -- LAST_INSERT_ID()：返回的是刚插入的记录的 id
            WHERE id = LAST_INSERT_ID();
        </selectKey>
    </insert>

    <!-- delete 标签里用来写“删”的 SQL 语句 -->
    <delete id="remove" parameterType="Integer">
        DELETE
        FROM t_user
        WHERE id = #{id};
    </delete>

    <!-- update 标签里用来写“改”的 SQL 语句 -->
    <update id="update" parameterType="Map">
        -- 这里得用到动态 SQL 语句，来实现客户端传了什么字段过来才更新什么字段，因为字段不是必传的
        UPDATE t_user
        -- set 标签：自动构建 SET 子句部分及其参数，并删掉最后的逗号和空格
        <set>
            -- if 标签：test 属性用来进行条件判断，条件满足才包含标签里的 SQL 片段
            <if test="name != null">
                name = #{name},
            </if>
            <if test="age != null">
                age = #{age},
            </if>
            <if test="height != null">
                height = #{height},
            </if>
            <if test="email != null">
                email = #{email},
            </if>
        </set>
        WHERE id = #{id};
    </update>
</mapper>