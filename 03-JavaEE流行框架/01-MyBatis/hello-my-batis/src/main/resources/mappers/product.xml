<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="dao.ProductDao">
    <insert id="save" parameterType="bean.ProductBean">
        INSERT INTO t_product (name, `desc`, price, brand, score, user_id)
        -- 外界传进来一个 product 对象，所以参数名只要和 bean 对象中的属性名一一对应，就能顺利匹配到参数值
        -- 存在对象嵌套时，直接使用嵌套对象的属性即可，MyBatis 就能自动去读取嵌套的 UserBean 对象
        VALUES (#{name}, #{desc}, #{price}, #{brand}, #{score}, #{userBean.id});

        <selectKey order="AFTER" keyProperty="id,createTime,updateTime" resultType="bean.ProductBean">
            SELECT
            id AS id,
            create_time AS createTime,
            update_time AS updateTime
            FROM t_product
            WHERE id = LAST_INSERT_ID();
        </selectKey>
    </insert>

    <select id="get" parameterType="Integer" resultType="bean.ProductBean">
        -- 因为有外键，所以查询时就是一对多表结构的多表查询
        SELECT t_product.id,
               t_product.create_time,
               t_product.update_time,
               t_product.name,
               t_product.price,
               t_product.desc,
               -- 只要把 t_user 表里的字段通过取别名的方式都列出来（注意 userBean 必须是 productBean 里对应对象的属性名，后面的属性名也必须是 userBean 里对应的属性名），MyBatis 就能自动封装成 UserBean 对象
               t_user.id          AS `userBean.id`,
               t_user.create_time AS `userBean.createTime`,
               t_user.update_time AS `userBean.updateTime`,
               t_user.name        AS `userBean.name`,
               t_user.age         AS `userBean.age`,
               t_user.height      AS `userBean.height`,
               t_user.email       AS `userBean.email`
        FROM t_product
                 LEFT JOIN t_user
                           ON t_product.user_id = t_user.id
        WHERE t_product.id = #{id};
    </select>
</mapper>