## ✅ 一、日志处理发展史

刚开始的时候，只有日志框架，没有日志门面接口，比如只有 JUL 和 Log4j 日志框架，项目里是直接使用日志框架的 API，所以一旦需要替换日志框架，就有很多地方得修改，非常麻烦。因此后来就出现了日志门面接口，比如 SLF4J 和 Log4j2，项目里是使用日志门面接口的 API，至于下层用的到底是什么日志框架，可以自由切换。`现在项目里一般都是用 SLF4J + Logback 或 Log4j2。`

* System.out.println
  * 最简单
  * 但是能做的事非常有限

* JUL（Java Util Logging）
  * JDK 自带的日志框架
  * 但是 API 不完善，很少人使用
* Log4j（Log For Java）
  * Apache 组织推出的日志框架
  * 但是 1.x 版本存在性能问题，已于 2015 年停止维护
* SLF4J（Simple Logging Facade For Java，酸辣粉）
  * Log4j 作者（Apache 组织里的一个人）推出的日志门面接口
  * 开发者面向该门面接口做开发，至于下层用的到底是什么日志框架，可以自由切换
* Logback
  * Log4j 作者（Apache 组织里的一个人）推出的日志框架，实现了 SLF4J 门面接口
  * 比 Log4j 性能高很多，SpringBoot 项目默认使用的日志框架
* Log4j2
  * Apache 组织推出的日志门面接口和日志框架，它既是接口也是实现
  * Log4j 的重大升级改进版，甚至改进了 Logback 的一些问题

## ✅ 二、为什么使用日志系统

开发环境：

* debug 打印变量值、函数调用到控制台，以便验证代码执行结果、追踪代码执行流程

生产环境：

* info 持久化关键配置的启动与关闭、关键业务流程的关键节点到日志文件，以便靠少量关键信息就能排查业务问题、分析用户行为偏好
* warn 持久化不影响功能正常运行的业务异常到日志文件，以便优化系统
* error 持久化影响功能正常运行的崩溃到日志文件，以便定位崩溃

## 三、怎么使用日志系统

#### ✅ 1、日志系统级别

日志系统从低到高一般有 6 个级别：TRACE < DEBUG < INFO < WARNING < ERROR < FATAL，设置为什么级别就只会输出当前级别及以上级别的信息，OFF 是关闭日志。不过实际开发中我们一般把 TRACE 并入 DEBUG、FATAL 并入 ERROR，只使用 4 个级别：

| 级别           | 用途                                                         | 问自己                                             | 生产环境 |
| -------------- | ------------------------------------------------------------ | -------------------------------------------------- | -------- |
| DEBUG - 调试   | 帮助开发者理解代码执行结果和代码执行过程，强调打印`代码`相关的东西<br />可以很详细，不用担心日志量 | 只想看看变量值、看看函数有没有调用？<br />用 DEBUG | 关闭     |
| INFO - 信息    | 记录系统正在做什么，强调记录`业务`相关的东西<br />应该精简，只记录关键配置的启动与关闭、关键业务流程的关键节点 | 想记录业务流程？<br />用 INFO                      | 开启     |
| WARNING - 警告 | 记录不影响功能正常运行的问题，开发者需关注但不一定需处理<br />一般就是抛业务异常的地方 | 出问题了但程序能继续？<br />用 WARN                | 开启     |
| ERROR - 错误   | 记录影响功能正常运行的崩溃，开发者需立即处理<br />一般就是抛系统异常的地方，必须记录异常堆栈 | 出问题了且需要人工介入？<br />用 ERROR             | 开启     |

```java
public class LoginService {
  private static final Logger log = LoggerFactory.getLogger(LoginService.class);

  /**
   * 用户登录主流程
   */
  public LoginResult login(String username, String password) {
    // traceId（追踪ID/链路ID）是一个唯一标识符，用来关联同一个请求在系统中产生的所有日志，并发请求时更容易过滤出相关联的日志
    String traceId = UUID.randomUUID().toString();

    // ====== INFO：关键业务入口 ======
    log.info("[{}] 用户登录请求, username: {}", traceId, username);
    
    try {
      // ====== DEBUG：开发时看到参数细节 ======
      log.debug("[{}] 参数校验开始, username: {}, passwordLength: {}",
                traceId, username, password != null ? password.length() : 0);
      if (StringUtils.isBlank(username) || StringUtils.isBlank(password)) {
        throw new LoginException("用户名或密码不能为空");
      }
      // ====== DEBUG：验证通过的确认 ======
      log.debug("[{}] 参数校验通过", traceId);

      // ====== INFO：关键业务完成 ======
      log.info("[{}] 用户登录成功, userId: {}, username: {}", traceId, user.getId(), username);
      return LoginResult.success(token);
    } catch (LoginException e) {
      // ====== WARN：用户输入错误（参数有效性校验异常、非系统问题） ======
      log.warn("[{}] 参数为空, username: {}", traceId, username);
      return LoginResult.fail(e.getMessage());
    } catch (Exception e) {
      // ====== ERROR：未预期的系统异常 ======
      log.error("[{}] 登录流程异常, username: {}", traceId, username, e);
      return LoginResult.fail("系统异常，请稍后重试");
    }
  }
}
```
