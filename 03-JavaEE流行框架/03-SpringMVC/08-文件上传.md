#### 1、添加依赖

首先安装 SpringMVC：

```XML
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>7.0.1</version>
</dependency>
```

然后我们知道 SpringMVC 是对 Servlet API 的封装，所以我们还需要安装 jakarta.servlet-api：

```XML
<dependency>
    <groupId>jakarta.servlet</groupId>
    <artifactId>jakarta.servlet-api</artifactId>
    <version>6.1.0</version>
    <scope>provided</scope>
</dependency>
```

然后我们还需要安装 commons-fileupload 这个三方库来实现文件上传：

```xml
<dependency>
  <groupId>org.apache.commons</groupId>
  <artifactId>commons-fileupload2-jakarta-servlet6</artifactId>
  <version>2.0.0-M4</version>
</dependency>
```

#### 2、在 web.xml 里做一些配置

> 这是非常老旧的配置方法，需要我们手动将 DispatcherServlet 的配置写入 web.xml 文件，这里仅做演示用
>
> Spring Boot 诞生后，在检测到 Spring MVC 的依赖后，会自动地、隐式地为我们配置好 DispatcherServlet，其默认拦截路径就是 "/"，让开发者能专注于写接口的业务代码，这个后面再说

```xml
<!DOCTYPE web-app PUBLIC
        "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
        "http://java.sun.com/dtd/web-app_2_3.dtd" >

<web-app>
    <display-name>Archetype Created Web Application</display-name>

    <!--
        配置主控制器

        配置主控制器为 SpringMVC 自带的 DispatcherServlet，这个 DispatcherServlet 是 SpringMVC 的“大脑”
        所有进入应用的请求都会先经过它，再由它负责分发给相应控制器的方法进行处理，我们可以把它想象成公司的“总机接线员”
    -->
    <servlet>
        <servlet-name>springmvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>

        <!--
            指定 Spring 配置文件的位置

            通过 <init-param> 参数告诉 DispatcherServlet 去哪里加载 Spring 的详细配置（classpath:applicationContext.xml）
            这个配置文件里会定义诸如组件扫描、数据源等具体的 Bean
        -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:applicationContext.xml</param-value>
        </init-param>
    </servlet>

    <!--
        配置主控制器可以拦截哪些请求

        通过 <servlet-mapping> 将 DispatcherServlet 的拦截模式设置为 "/"
        这意味着 DispatcherServlet 会拦截所有的HTTP请求（如 /user, /api/login等），但通常不包括静态资源（如 .js, .css, .jpg）
    -->
    <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

#### 3、创建 Spring 的配置文件，做一些配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd">
    <!--
        通过 context:component-scan 标签告诉 Spring 框架哪个包里的类是通过注解实现 IoC 的
        Spring 框架就会扫描这个包里所有有注解的类来自动创建对象并放到 IoC 容器里
    -->
    <context:component-scan base-package="com.ineyee"/>

    <!-- 让静态资源走服务器默认的处理，而不是被 DispatcherServlet 拦截 -->
    <mvc:default-servlet-handler/>
    <!--
        但是添加了 mvc:default-servlet-handler 会导致 @Controller 无法处理请求
        所以还得加上 mvc:annotation-driven 来保证 @Controller 可以正常处理请求
    -->
    <mvc:annotation-driven/>
</beans>
```

#### 4、创建 controller 层，编写接口

* 第一步：在 Spring 的配置文件里把 commons-fileupload 三方库的 StandardServletMultipartResolver 添加到 IoC 容器，id 值固定为 multipartResolver，将来 SpringMVC 就会通过这个 id 值拿到这个解析器去解析 multipart/form-data 请求的参数

```xml
<bean id="multipartResolver" class="org.springframework.web.multipart.support.StandardServletMultipartResolver"/>
```

* 第二步：在 web.xml 里为 DispatcherServlet 配置 multipart/form-data 请求的 multipart-config，否则解析器无法正确解析参数

```xml
<!-- 配置 multipart/form-data 请求的 multipart-config -->
<multipart-config>
    <!--
        设置文件上传时的临时目录，默认是 Servlet 容器的临时目录，一般不设置采用默认的就行
        文件上传时，数据会先写入到硬盘上的临时目录，而不是直接放到内存中，这样可以防止上传大文件时占用过多内存
        上传完成后，再将文件移动到指定的目标目录
    -->
    <location>/tmp</location>
    <!--
        设置单个文件的最大字节数，单位为字节
        默认值是 -1，表示无限制
        如果上传的文件超过该大小限制，Servlet 会抛出异常（如 IOException）
        例如这里设置为 10485760 字节，即 10 MB
    -->
    <max-file-size>10485760</max-file-size>
    <!--
        设置一次上传请求中所有文件的总大小上限，单位为字节
            默认值是 -1，表示无限制
            如果上传的文件总大小超过该限制，Servlet 会抛出异常
            例如这里设置为 20971520 字节，即 20 MB
        -->
    <max-request-size>20971520</max-request-size>
    <!--
        设置文件写入到临时文件之前，允许保存在内存中的临界值，单位为字节
        当文件大小超过该值时，才会写入硬盘临时目录；否则保存在内存中
        默认是 0，表示所有上传文件都直接写入硬盘临时目录
    -->
    <file-size-threshold>0</file-size-threshold>
</multipart-config>
```

* 第三部：使用 @RequestParam 注解一个参数一个参数获取即可，只不过文件参数的类型固定为 MultipartFile，单文件和多文件上传都很简单

```java
// 假设客户端发送的 post 请求为（字段名要跟客户端约定好）：
// url = http://localhost:9999/{{applicationContext}}/uploadFile
// body =
//     --Boundary+1234567890
//     Content-Disposition: form-data; name="email"
//     zhangsan@qq.com
//     --Boundary+1234567890
//     Content-Disposition: form-data; name="username"
//     zhangsan张三
//     --Boundary+1234567890
//     Content-Disposition: form-data; name="file"
//     filedata

@PostMapping("/uploadFile")
@ResponseBody
public String uploadFile(@RequestParam(value = "email", required = true) String email,
                         @RequestParam(value = "username", required = false) String username,
                         @RequestParam(value = "file", required = true) MultipartFile file,
                         HttpServletRequest req) throws IOException {
    // 获取当前项目的 applicationContext
    ServletContext applicationContext = req.getServletContext();
    // 设置文件在服务器上的存储目录，这里存储在当前项目根目录下的 upload/image 文件夹里
    // 一般就是存储在 upload/text、upload/image、upload/audio、upload/video 这类文件夹里
    // 文件夹存在的话就是直接获取
    String dirPath = applicationContext.getRealPath("/upload/image");
    // 不存在的话就创建，确保目录存在
    File dir = new File(dirPath);
    if (!dir.exists()) {
        // 创建目录及其父目录
        boolean dirCreated = dir.mkdirs();
        if (!dirCreated) {
            throw new IOException("Failed to create directory: " + dirPath);
        }
    }
    // 设置文件在服务器上的文件名
    // 不建议用时间戳，因为大量用户可能在同一时间上传文件，文件名会重复
    // 更不建议用客户端传上来的原始文件名，因为用户可能会上传同名文件，文件名会重复
    // 建议使用 UUID 生成唯一的随机字符串来作为文件名
    String fileName = UUID.randomUUID() + "." + FilenameUtils.getExtension(file.getOriginalFilename());
    // 文件路径
    String filePath = dirPath + "/" + fileName;

    // 把文件存储到服务器硬盘上
    file.transferTo(new File(filePath));

    // 这里我们是把文件存储到我们自己的服务器上，所以只需要把文件的相对路径（/upload/image/xxx.png 这种）存储到数据库并返回给客户端就可以了
    // 因为前面的 ip 地址、端口号、applicationContext 我们都可能会修改，所以让客户端拿到相对路径后拼接上前面的部分就能访问到文件了
    //
    // 如果是把文件存储到三方 OSS，那就直接把文件的 URL（http://xxx/xxx/xxx.png 这种） 存储到数据库并返回给客户端就可以了
    String relativePath = "/upload/image/" + fileName;

    return "uploadFile success = " + email + " " + username + " " + relativePath;
}
```

```java
// 假设客户端发送的 post 请求为（字段名要跟客户端约定好）：
// url = http://localhost:9999/{{applicationContext}}/uploadFiles
// body =
//     --Boundary+1234567890
//     Content-Disposition: form-data; name="email"
//     zhangsan@qq.com
//     --Boundary+1234567890
//     Content-Disposition: form-data; name="username"
//     zhangsan张三
//     --Boundary+1234567890
//     Content-Disposition: form-data; name="files"
//     filedata1、filedata2
@PostMapping("/uploadFiles")
@ResponseBody
public String uploadFiles(@RequestParam(value = "email", required = true) String email,
                          @RequestParam(value = "username", required = false) String username,
                          @RequestParam(value = "files", required = true) List<MultipartFile> files,
                          HttpServletRequest req) throws IOException {
    // 获取当前项目的 applicationContext
    ServletContext applicationContext = req.getServletContext();
    // 设置文件在服务器上的存储目录，这里存储在当前项目根目录下的 upload/image 文件夹里
    // 一般就是存储在 upload/text、upload/image、upload/audio、upload/video 这类文件夹里
    // 文件夹存在的话就是直接获取
    String dirPath = applicationContext.getRealPath("/upload/image");
    // 不存在的话就创建，确保目录存在
    File dir = new File(dirPath);
    if (!dir.exists()) {
        // 创建目录及其父目录
        boolean dirCreated = dir.mkdirs();
        if (!dirCreated) {
            throw new IOException("Failed to create directory: " + dirPath);
        }
    }

    // 处理所有上传的文件
    List<String> relativePaths = new ArrayList<>();
    for (MultipartFile file : files) {
        // 设置文件在服务器上的文件名
        // 不建议用时间戳，因为大量用户可能在同一时间上传文件，文件名会重复
        // 更不建议用客户端传上来的原始文件名，因为用户可能会上传同名文件，文件名会重复
        // 建议使用 UUID 生成唯一的随机字符串来作为文件名
        String fileName = UUID.randomUUID() + "." + FilenameUtils.getExtension(file.getOriginalFilename());
        // 文件路径
        String filePath = dirPath + "/" + fileName;

        // 把文件存储到服务器硬盘上
        file.transferTo(new File(filePath));

        // 这里我们是把文件存储到我们自己的服务器上，所以只需要把文件的相对路径（/upload/image/xxx.png 这种）存储到数据库并返回给客户端就可以了
        // 因为前面的 ip 地址、端口号、applicationContext 我们都可能会修改，所以让客户端拿到相对路径后拼接上前面的部分就能访问到文件了
        //
        // 如果是把文件存储到三方 OSS，那就直接把文件的 URL（http://xxx/xxx/xxx.png 这种） 存储到数据库并返回给客户端就可以了
        String relativePath = "/upload/image/" + fileName;
        relativePaths.add(relativePath);
    }

    return "uploadFile success = " + email + " " + username + " " + relativePaths;
}
```

