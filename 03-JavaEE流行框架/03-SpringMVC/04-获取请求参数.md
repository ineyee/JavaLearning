#### 1、添加依赖

首先安装 SpringMVC：

```XML
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>7.0.1</version>
</dependency>
```

然后我们知道 SpringMVC 是对 Servlet API 的封装，所以我们还需要安装 jakarta.servlet-api：

```XML
<dependency>
    <groupId>jakarta.servlet</groupId>
    <artifactId>jakarta.servlet-api</artifactId>
    <version>6.1.0</version>
    <scope>provided</scope>
</dependency>
```

#### 2、在 web.xml 里做一些配置

> 这是非常老旧的配置方法，需要我们手动将 DispatcherServlet 的配置写入 web.xml 文件，这里仅做演示用
>
> Spring Boot 诞生后，在检测到 Spring MVC 的依赖后，会自动地、隐式地为我们配置好 DispatcherServlet，其默认拦截路径就是 "/"，让开发者能专注于写接口的业务代码，这个后面再说

```xml
<!DOCTYPE web-app PUBLIC
        "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
        "http://java.sun.com/dtd/web-app_2_3.dtd" >

<web-app>
    <display-name>Archetype Created Web Application</display-name>

    <!--
        配置主控制器

        配置主控制器为 SpringMVC 自带的 DispatcherServlet，这个 DispatcherServlet 是 SpringMVC 的“大脑”
        所有进入应用的请求都会先经过它，再由它负责分发给相应控制器的方法进行处理，我们可以把它想象成公司的“总机接线员”
    -->
    <servlet>
        <servlet-name>springmvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>

        <!--
            指定 Spring 配置文件的位置

            通过 <init-param> 参数告诉 DispatcherServlet 去哪里加载 Spring 的详细配置（classpath:applicationContext.xml）
            这个配置文件里会定义诸如组件扫描、数据源等具体的 Bean
        -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:applicationContext.xml</param-value>
        </init-param>
    </servlet>

    <!--
        配置主控制器可以拦截哪些请求

        通过 <servlet-mapping> 将 DispatcherServlet 的拦截模式设置为 "/"
        这意味着 DispatcherServlet 会拦截所有的HTTP请求（如 /user, /api/login等），但通常不包括静态资源（如 .js, .css, .jpg）
    -->
    <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

#### 3、创建 Spring 的配置文件，做一些配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd">
    <!--
        通过 context:component-scan 标签告诉 Spring 框架哪个包里的类是通过注解实现 IoC 的
        Spring 框架就会扫描这个包里所有有注解的类来自动创建对象并放到 IoC 容器里
    -->
    <context:component-scan base-package="com.ineyee"/>

    <!-- 让静态资源走服务器默认的处理，而不是被 DispatcherServlet 拦截 -->
    <mvc:default-servlet-handler/>
    <!--
        但是添加了 mvc:default-servlet-handler 会导致 @Controller 无法处理请求
        所以还得加上 mvc:annotation-driven 来保证 @Controller 可以正常处理请求
    -->
    <mvc:annotation-driven/>
</beans>
```

#### 4、创建 controller 层，编写接口

###### 4.1 获取 get 请求的参数

**4.1.1 当参数以“查询字符串”的方式传递时，http://xxx?id=123456**

* 方式一：使用 @RequestParam 注解一个参数一个参数获取

```java
// 假设客户端发送的 get 请求为：http://localhost:9999/{{applicationContext}}/test01?partyMember=true&age=18&height=1.88&salary=11.21&name=ineyee

@GetMapping("/test01")
@ResponseBody
// 使用 @RequestParam 注解一个参数一个参数获取
//     value：get 请求里的参数名，可能跟我们 test01 方法里的参数名不同
//     required：参数是否必传，默认为 true
public String test01(@RequestParam(value = "partyMember", required = true) Boolean isPartyMember,
                     @RequestParam(value = "age", required = false) Integer age,
                     @RequestParam(value = "height", required = false) Double height,
                     @RequestParam(value = "salary", required = false) BigDecimal salary,
                     @RequestParam(value = "name", required = true) String name) {
  return "test01 success = " + isPartyMember + " " + age + " " + height + " " + salary + " " + name;
}
```

* 方式二：把所有参数都获取到一个请求参数模型里

```xml
<!--
	在 pom.xml 里添加校验参数是否必传相关的依赖
	jakarta.validation-api 是接口，hibernate-validator 是具体实现
-->
<dependency>
    <groupId>jakarta.validation</groupId>
    <artifactId>jakarta.validation-api</artifactId>
    <version>3.0.2</version>
</dependency>
<dependency>
    <groupId>org.hibernate.validator</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>8.0.0.Final</version>
</dependency>
```

```xml
<!-- 在 spring 配置文件里添加校验参数是否必传相关的配置 -->

<!-- 配置验证器 -->
<bean id="validator" class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"/>
<!-- 启用方法级别的验证 -->
<bean class="org.springframework.validation.beanvalidation.MethodValidationPostProcessor"/>
<!-- 启用 Spring MVC 注解驱动，同时也会启用参数校验功能（@Valid 等） -->
<mvc:annotation-driven/>
```

```java
// 创建一个请求参数模型，该模型里的属性要跟请求参数完全一一对应，名字和数量都必须完全一样
public class UserRequest {
    // 基本数据类型
    @NotNull(message = "partyMember cant be empty")
    private Boolean isPartyMember;
    private Integer age;
    private Double height;

    // BigDecimal
    private BigDecimal salary;

    // 字符串
    @NotNull(message = "name cant be empty")
    private String name;

    public Boolean getPartyMember() {
        return isPartyMember;
    }

    public void setPartyMember(Boolean partyMember) {
        isPartyMember = partyMember;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Double getHeight() {
        return height;
    }

    public void setHeight(Double height) {
        this.height = height;
    }

    public BigDecimal getSalary() {
        return salary;
    }

    public void setSalary(BigDecimal salary) {
        this.salary = salary;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "UserRequest{" +
                "isPartyMember=" + isPartyMember +
                ", age=" + age +
                ", height=" + height +
                ", salary=" + salary +
                ", name='" + name + '\'' +
                '}';
    }
}
```

```java
// 假设客户端发送的 get 请求为：http://localhost:9999/{{applicationContext}}/test02?partyMember=true&age=18&height=1.88&salary=11.21&name=ineyee

@GetMapping("/test02")
@ResponseBody
// 使用 @Valid 注解对参数进行校验
public String test02(@Valid UserRequest userRequest) {
  return "test02 success = " + userQueryParam;
}
```

* 方式三：使用 @RequestParam 注解把所有参数都获取到一个 Map 里（无法设置参数是否必传）

```java
// 假设客户端发送的 get 请求为：http://localhost:9999/{{applicationContext}}/test03?partyMember=true&age=18&height=1.88&salary=11.21&name=ineyee

@GetMapping("/test03")
@ResponseBody
// 使用 @RequestParam 注解获取参数
public String test03(@RequestParam Map<String, Object> params) {
  return "test03 success = " + params;
}
```

* 方式四：使用 @RequestParam 注解把所有参数都获取到一个 List 里

```java
// 假设客户端发送的 get 请求为：http://localhost:9999/{{applicationContext}}/test04?ids=1&ids=2&ids=3

@GetMapping("/test04")
@ResponseBody
// 使用 @RequestParam 注解获取参数
public String test04(@RequestParam("ids") List<String> ids) {
  return "test04 success = " + ids;
}
```

**4.1.2 当参数以“路径参数”的方式传递时，http://xxx/123456**

```java
// 假设客户端发送的 get 请求为：http://localhost:9999/{{applicationContext}}/test05/123456，其中 123456 为 id 参数的值

@GetMapping("/test05/{id}")
@ResponseBody
// 使用 @PathVariable 注解获取参数
//     value：get 请求里的参数名，可能跟我们 test05 方法里的参数名不同
//     required：参数是否必传，默认为 true
public String test05(@PathVariable(value = "id", required = true) String id) {
  return "test05 success = " + id;
}
```

###### 4.2 获取 post 请求的参数

**4.2.1 当参数以表单提交时**

* 方式一：使用 @RequestParam 注解一个参数一个参数获取

```java
// 假设客户端发送的 post 请求为：
// url = http://localhost:9999/{{applicationContext}}/test01
// body = partyMember=true&age=18&height=1.88&salary=11.21&name=ineyee

@PostMapping(value = "/test01")
@ResponseBody
// 使用 @RequestParam 注解一个参数一个参数获取
//     value：post 请求里的参数名，可能跟我们 test01 方法里的参数名不同
//     required：参数是否必传，默认为 true
public String test01(@RequestParam(value = "partyMember", required = true) Boolean isPartyMember,
                     @RequestParam(value = "age", required = false) Integer age,
                     @RequestParam(value = "height", required = false) Double height,
                     @RequestParam(value = "salary", required = false) BigDecimal salary,
                     @RequestParam(value = "name", required = true) String name) {
  return "test01 success = " + isPartyMember + " " + age + " " + height + " " + salary + " " + name;
}
```

* 方式二：把所有参数都获取到一个请求参数模型里

```xml
<!--
	在 pom.xml 里添加校验参数是否必传相关的依赖
	jakarta.validation-api 是接口，hibernate-validator 是具体实现
-->
<dependency>
    <groupId>jakarta.validation</groupId>
    <artifactId>jakarta.validation-api</artifactId>
    <version>3.0.2</version>
</dependency>
<dependency>
    <groupId>org.hibernate.validator</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>8.0.0.Final</version>
</dependency>
```

```xml
<!-- 在 spring 配置文件里添加校验参数是否必传相关的配置 -->

<!-- 配置验证器 -->
<bean id="validator" class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"/>
<!-- 启用方法级别的验证 -->
<bean class="org.springframework.validation.beanvalidation.MethodValidationPostProcessor"/>
<!-- 启用 Spring MVC 注解驱动，同时也会启用参数校验功能（@Valid 等） -->
<mvc:annotation-driven/>
```

```java
// 创建一个请求参数模型，该模型里的属性要跟请求参数完全一一对应，名字和数量都必须完全一样
public class UserRequest {
    // 基本数据类型
    @NotNull(message = "partyMember cant be empty")
    private Boolean isPartyMember;
    private Integer age;
    private Double height;

    // BigDecimal
    private BigDecimal salary;

    // 字符串
    @NotNull(message = "name cant be empty")
    private String name;

    public Boolean getPartyMember() {
        return isPartyMember;
    }

    public void setPartyMember(Boolean partyMember) {
        isPartyMember = partyMember;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Double getHeight() {
        return height;
    }

    public void setHeight(Double height) {
        this.height = height;
    }

    public BigDecimal getSalary() {
        return salary;
    }

    public void setSalary(BigDecimal salary) {
        this.salary = salary;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "UserRequest{" +
                "isPartyMember=" + isPartyMember +
                ", age=" + age +
                ", height=" + height +
                ", salary=" + salary +
                ", name='" + name + '\'' +
                '}';
    }
}
```

```java
// 假设客户端发送的 post 请求为：
// url = http://localhost:9999/{{applicationContext}}/test02
// body = partyMember=true&age=18&height=1.88&salary=11.21&name=ineyee

@PostMapping("/test02")
@ResponseBody
// 使用 @Valid 注解对参数进行校验
public String test02(@Valid UserRequest userRequest) {
  return "test02 success = " + userQueryParam;
}
```

* 方式三：使用 @RequestParam 注解把所有参数都获取到一个 Map 里（无法设置参数是否必传）

```java
// 假设客户端发送的 post 请求为：
// url = http://localhost:9999/{{applicationContext}}/test03
// body = partyMember=true&age=18&height=1.88&salary=11.21&name=ineyee

@PostMapping("/test03")
@ResponseBody
// 使用 @RequestParam 注解获取参数
public String test03(@RequestParam Map<String, Object> params) {
  return "test03 success = " + params;
}
```

* 方式四：使用 @RequestParam 注解把所有参数都获取到一个 List 里

```java
// 假设客户端发送的 post 请求为：
// url = http://localhost:9999/{{applicationContext}}/test04
// body = ids=1&ids=2&ids=3

@PostMapping("/test04")
@ResponseBody
// 使用 @RequestParam 注解获取参数
public String test04(@RequestParam("ids") List<String> ids) {
  return "test04 success = " + ids;
}
```

**4.2.2 当参数以 JSON 提交时**

无论是方式一还是方式二，都先搞定这两个

```xml
<!-- 首先在 pom.xml 里添加 Java 对象和 Json 字符串互转的库 -->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.15.2</version>
</dependency>
```

```xml
<!-- 然后在 spring 配置文件里添加互转库的配置 -->
<mvc:annotation-driven>
    <mvc:message-converters>
        <bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter">
            <property name="defaultCharset" value="utf-8"/>
        </bean>
    </mvc:message-converters>
</mvc:annotation-driven>
```

* 方式一：使用 @RequestBody 注解把所有参数都获取到一个请求参数模型里

```xml
<!--
	在 pom.xml 里添加校验参数是否必传相关的依赖
	jakarta.validation-api 是接口，hibernate-validator 是具体实现
-->
<dependency>
    <groupId>jakarta.validation</groupId>
    <artifactId>jakarta.validation-api</artifactId>
    <version>3.0.2</version>
</dependency>
<dependency>
    <groupId>org.hibernate.validator</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>8.0.0.Final</version>
</dependency>
```

```xml
<!-- 在 spring 配置文件里添加校验参数是否必传相关的配置 -->

<!-- 配置验证器 -->
<bean id="validator" class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"/>
<!-- 启用方法级别的验证 -->
<bean class="org.springframework.validation.beanvalidation.MethodValidationPostProcessor"/>
<!-- 启用 Spring MVC 注解驱动，同时也会启用参数校验功能（@Valid 等） -->
<mvc:annotation-driven/>
```

```java
// 创建一个请求参数模型，该模型里的属性要跟请求参数完全一一对应，名字和数量都必须完全一样
public class UserRequest {
    // 基本数据类型
    @NotNull(message = "partyMember cant be empty")
    private Boolean isPartyMember;
    private Integer age;
    private Double height;

    // BigDecimal
    private BigDecimal salary;

    // 字符串
    @NotNull(message = "name cant be empty")
    private String name;

    public Boolean getPartyMember() {
        return isPartyMember;
    }

    public void setPartyMember(Boolean partyMember) {
        isPartyMember = partyMember;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Double getHeight() {
        return height;
    }

    public void setHeight(Double height) {
        this.height = height;
    }

    public BigDecimal getSalary() {
        return salary;
    }

    public void setSalary(BigDecimal salary) {
        this.salary = salary;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "UserRequest{" +
                "isPartyMember=" + isPartyMember +
                ", age=" + age +
                ", height=" + height +
                ", salary=" + salary +
                ", name='" + name + '\'' +
                '}';
    }
}
```

```java
// 假设客户端发送的 post 请求为：
// url = http://localhost:9999/{{applicationContext}}/test05
// body = {"partyMember":true,"age":18,"height":1.88,"salary":11.21,"name":"ineyee"}

@PostMapping("/test05")
@ResponseBody
// 使用 @RequestBody 注解获取参数
// 使用 @Valid 注解对参数进行校验
public String test05(@Valid @RequestBody UserRequest userRequest) {
  return "test05 success = " + userQueryParam;
}
```

* 方式二：使用 @RequestBody 注解把所有参数都获取到一个 Map 里（无法设置参数是否必传）

```java
// 假设客户端发送的 post 请求为：
// url = http://localhost:9999/{{applicationContext}}/test06
// body = {"ids": [1, 2, 3]}

@PostMapping("/test06")
@ResponseBody
// 使用 @RequestBody 注解获取参数
public String test06(@RequestBody Map<String, Object> params) {
  return "test06 success = " + params.get("ids");
}
```

#### 5、get 请求、post 请求的请求参数乱码处理

在 web.xml 文件里加上一个字符编码过滤器即可：

```xml
<!-- 字符编码过滤器，用来处理 HTTP 请求的字符编码 -->
<filter>
    <!-- 过滤器的名字，这个名字是我们自己起的，后面在 filter-mapping 中会用到 -->
    <filter-name>characterEncodingFilter</filter-name>
    <!-- 过滤器的实现类，使用 Spring 框架自带的 CharacterEncodingFilter 类 -->
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>

    <!--
        告诉过滤器强制使用 UTF-8 编码来处理请求参数，UTF-8 是目前最通用的字符编码
    -->
    <init-param>
        <param-name>encoding</param-name>
        <param-value>UTF-8</param-value>
    </init-param>
    <init-param>
        <param-name>forceEncoding</param-name>
        <param-value>true</param-value>
    </init-param>
</filter>
<!-- 配置字符编码过滤器的拦截范围，/* 代表会拦截接口型请求 + 静态资源请求 + 动态资源请求所有的 HTTP 请求-->
<filter-mapping>
    <filter-name>characterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

