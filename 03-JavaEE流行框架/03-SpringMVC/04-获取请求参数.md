#### 1、添加依赖

首先安装 SpringMVC：

```XML
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>7.0.1</version>
</dependency>
```

然后我们知道 SpringMVC 是对 Servlet API 的封装，所以我们还需要安装 jakarta.servlet-api：

```XML
<dependency>
    <groupId>jakarta.servlet</groupId>
    <artifactId>jakarta.servlet-api</artifactId>
    <version>6.1.0</version>
    <scope>provided</scope>
</dependency>
```

#### 2、在 web.xml 里做一些配置

> 这是非常老旧的配置方法，需要我们手动将 DispatcherServlet 的配置写入 web.xml 文件，这里仅做演示用
>
> Spring Boot 诞生后，在检测到 Spring MVC 的依赖后，会自动地、隐式地为我们配置好 DispatcherServlet，其默认拦截路径就是 "/"，让开发者能专注于写接口的业务代码，这个后面再说

```xml
<!DOCTYPE web-app PUBLIC
        "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
        "http://java.sun.com/dtd/web-app_2_3.dtd" >

<web-app>
    <display-name>Archetype Created Web Application</display-name>

    <!--
        配置主控制器

        配置主控制器为 SpringMVC 自带的 DispatcherServlet，这个 DispatcherServlet 是 SpringMVC 的“大脑”
        所有进入应用的请求都会先经过它，再由它负责分发给相应控制器的方法进行处理，我们可以把它想象成公司的“总机接线员”
    -->
    <servlet>
        <!-- 主控制器的名字，这个名字是我们自己起的，后面在 servlet-mapping 中会用到 -->
        <servlet-name>springmvc</servlet-name>
        <!-- 主控制器的实现类，使用 SpringMVC 自带的 DispatcherServlet 类 -->
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>

        <!--
            指定 Spring 配置文件的位置

            通过 <init-param> 参数告诉 DispatcherServlet 去哪里加载 Spring 的配置文件（classpath:applicationContext.xml）
        -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:applicationContext.xml</param-value>
        </init-param>
    </servlet>

    <!--
        配置主控制器可以拦截哪些请求，注意还需配合 Spring 配置文件里的 <mvc:default-servlet-handler/> 和 <mvc:annotation-driven/> 一起使用

        通过 <servlet-mapping> 将 DispatcherServlet 的拦截模式设置为 "/"，这意味着 DispatcherServlet 会拦截接口型请求，会拦截静态资源型请求，不会拦截动态资源型请求（拦截 2 个）
    -->
    <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

#### 3、创建 Spring 的配置文件，做一些配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd">
    <!--
        通过 context:component-scan 标签告诉 Spring 框架哪个包里的类是通过注解实现 IoC 的
        Spring 框架就会扫描这个包里所有有注解的类来自动创建对象并放到 IoC 容器里
    -->
    <context:component-scan base-package="com.ineyee"/>

    <!--
        DispatcherServlet 虽然拦截到了静态资源
        但是我们不让它处理，而是转交给默认的静态资源 Servlet 走服务器默认的处理
    -->
    <mvc:default-servlet-handler/>
    <!--
        但是添加了 mvc:default-servlet-handler 后又会导致 @Controller 等注解无法处理接口型请求
        所以还得加上 mvc:annotation-driven 注解驱动来保证 @Controller 等注解可以正常处理接口型请求
    -->
    <mvc:annotation-driven/>
</beans>
```

#### 4、创建 controller 层，编写接口

## 一、获取 get 请求的参数

#### 1、当参数以“查询字符串”的方式传递时，http://xxx?id=123456

###### 1.1 方式一：使用 @RequestParam 注解一个参数一个参数获取（可以设置参数是否必传）

```java
// 假设客户端发送的 get 请求为：http://localhost:9999/{{applicationContext}}/test01?partyMember=true&age=18&height=1.88&salary=11.21&name=ineyee
@GetMapping(value = "/test01")
@ResponseBody
// 使用 @RequestParam 注解一个参数一个参数获取
//     value：get 请求里的参数名，可能跟我们 test01 方法里的参数名不同
//     required：参数是否必传，默认为 true
public String test01(@RequestParam(value = "partyMember", required = true) Boolean isPartyMember,
                     @RequestParam(value = "age", required = false) Integer age,
                     @RequestParam(value = "height", required = false) Double height,
                     @RequestParam(value = "salary", required = false) BigDecimal salary,
                     @RequestParam(value = "name", required = true) String name) {
  return "test01 success = " + isPartyMember + " " + age + " " + height + " " + salary + " " + name;
}
```

###### 1.2 方式二：把所有参数都获取到一个 dto 请求参数模型里（可以设置参数是否必传）

* 在 pom.xml 里添加校验参数是否必传相关的依赖

```xml
<!--
	jakarta.validation-api 是接口，hibernate-validator 是具体实现
-->
<dependency>
    <groupId>jakarta.validation</groupId>
    <artifactId>jakarta.validation-api</artifactId>
    <version>3.0.2</version>
</dependency>
<dependency>
    <groupId>org.hibernate.validator</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>8.0.0.Final</version>
</dependency>
```

* 在 Spring 配置文件里添加校验参数是否必传相关的配置

```xml
<!-- 配置验证器 -->
<bean id="validator" class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"/>
<!-- 启用方法级别的验证 -->
<bean class="org.springframework.validation.beanvalidation.MethodValidationPostProcessor"/>

<!-- 自动启用参数校验功能（@Valid 等） -->
<mvc:annotation-driven/>
```

* 创建一个 dto 请求参数模型，该模型里的属性要跟请求参数完全一一对应，名字和数量都必须完全一样，我们可以在请求参数模型里设置参数是否必传

```java
package com.ineyee.dto;

import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;

public class UserCreateDto {
    // 基本数据类型
    @NotNull(message = "partyMember cant be empty")
    private Boolean isPartyMember;
    private Integer age;
    private Double height;

    // BigDecimal
    private BigDecimal salary;

    // 字符串
    @NotNull(message = "name cant be empty")
    private String name;

    public Boolean getPartyMember() {
        return isPartyMember;
    }

    public void setPartyMember(Boolean partyMember) {
        isPartyMember = partyMember;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Double getHeight() {
        return height;
    }

    public void setHeight(Double height) {
        this.height = height;
    }

    public BigDecimal getSalary() {
        return salary;
    }

    public void setSalary(BigDecimal salary) {
        this.salary = salary;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "UserCreateDto{" +
                "isPartyMember=" + isPartyMember +
                ", age=" + age +
                ", height=" + height +
                ", salary=" + salary +
                ", name='" + name + '\'' +
                '}';
    }
}
```

* 编写接口，接收参数

```java
// 假设客户端发送的 get 请求为：http://localhost:9999/{{applicationContext}}/test02?partyMember=true&age=18&height=1.88&salary=11.21&name=ineyee
@GetMapping("/test02")
@ResponseBody
// 使用 @Valid 注解对参数进行校验
public String test02(@Valid UserCreateDto userCreateDto) {
  return "test02 success = " + userCreateDto;
}
```

###### 1.3 方式三：使用 @RequestParam 注解把所有参数都获取到一个 Map 里（不可以设置参数是否必传）

```java
// 假设客户端发送的 get 请求为：http://localhost:9999/{{applicationContext}}/test03?partyMember=true&age=18&height=1.88&salary=11.21&name=ineyee
@GetMapping("/test03")
@ResponseBody
// 使用 @RequestParam 注解获取参数
public String test03(@RequestParam Map<String, Object> params) {
  return "test03 success = " + params;
}
```

###### 1.4 方式四：使用 @RequestParam 注解把所有参数都获取到一个 List 里（可以设置参数是否必传）

```java
// 假设客户端发送的 get 请求为：http://localhost:9999/{{applicationContext}}/test04?ids=1&ids=2&ids=3

@GetMapping("/test04")
@ResponseBody
// 使用 @RequestParam 注解获取参数
public String test04(@RequestParam("ids") List<String> ids) {
  return "test04 success = " + ids;
}
```

#### 2、当参数以“路径参数”的方式传递时，http://xxx/123456

```java
// 假设客户端发送的 get 请求为：http://localhost:9999/{{applicationContext}}/test05/123456，其中 123456 为 id 参数的值
@GetMapping("/test05/{id}")
@ResponseBody
// 使用 @PathVariable 注解获取参数
//     value：get 请求里的参数名，可能跟我们 test05 方法里的参数名不同
//     required：参数是否必传，默认为 true
public String test05(@PathVariable(value = "id", required = true) String id) {
  return "test05 success = " + id;
}
```

## 二、获取 post 请求的参数

#### 1、当参数以表单提交时

跟 get 请求 + 参数以“查询字符串”传递的 4 种获取方式一模一样

```java
// 假设客户端发送的 post 请求为：
// url = http://localhost:9999/{{applicationContext}}/test01|test02|test03|test04
// body = partyMember=true&age=18&height=1.88&salary=11.21&name=ineyee
```

#### 2、当参数以 JSON 提交时

无论是方式一还是方式二，都先搞定这两个：

* 首先在 pom.xml 里添加 Java 对象或 Map 和 Json 字符串互转的库

```xml
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.15.2</version>
</dependency>
```

* 然后在 Spring 配置文件里添加互转库的配置

```xml
<!-- 自动注册消息转换器（mvc:message-converters） -->
<mvc:annotation-driven>
  <mvc:message-converters>
    <bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter"/>
  </mvc:message-converters>
</mvc:annotation-driven>
```

###### 2.1 方式一：使用 @RequestBody 注解把所有参数都获取到一个请求参数模型里（可以设置参数是否必传）

* 在 pom.xml 里添加校验参数是否必传相关的依赖

```xml
<!--
	jakarta.validation-api 是接口，hibernate-validator 是具体实现
-->
<dependency>
    <groupId>jakarta.validation</groupId>
    <artifactId>jakarta.validation-api</artifactId>
    <version>3.0.2</version>
</dependency>
<dependency>
    <groupId>org.hibernate.validator</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>8.0.0.Final</version>
</dependency>
```

* 在 Spring 配置文件里添加校验参数是否必传相关的配置

```xml
<!-- 配置验证器 -->
<bean id="validator" class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"/>
<!-- 启用方法级别的验证 -->
<bean class="org.springframework.validation.beanvalidation.MethodValidationPostProcessor"/>

<!-- 自动启用参数校验功能（@Valid 等） -->
<mvc:annotation-driven/>
```

* 创建一个 dto 请求参数模型，该模型里的属性要跟请求参数完全一一对应，名字和数量都必须完全一样，我们可以在请求参数模型里设置参数是否必传

```java
package com.ineyee.dto;

import jakarta.validation.constraints.NotNull;

public class UserUpdateDto {
    @NotNull(message = "name cant be empty")
    private String name;

    private Integer age;

    private Double height;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Double getHeight() {
        return height;
    }

    public void setHeight(Double height) {
        this.height = height;
    }

    @Override
    public String toString() {
        return "UserUpdateDto{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", height=" + height +
                '}';
    }
}
```

* 编写接口，接收参数

```java
// 假设客户端发送的 post 请求为：
// url = http://localhost:9999/{{applicationContext}}/test05
// body = {"partyMember":true,"age":18,"height":1.88,"salary":11.21,"name":"ineyee"}
@PostMapping("/test05")
@ResponseBody
// 使用 @RequestBody 注解获取参数
// 使用 @Valid 注解对参数进行校验
//
// 只要项目里添加并配置了 jackson-databind 依赖，其余什么都不需要做，只要该方法的参数是 Java 对象或 Map，Spring 框架就会自动把客户端请求体的 JSON 字符串转为 Java 对象或 Map
public String test05(@Valid @RequestBody UserUpdateDto userUpdateDto) {
    return "test05 success = " + userUpdateDto;
}
```

###### 2.2 方式二：使用 @RequestBody 注解把所有参数都获取到一个 Map 里（不可以设置参数是否必传）

```java
// 假设客户端发送的 post 请求为：
// url = http://localhost:9999/{{applicationContext}}/test06
// body = {"ids": [1, 2, 3]}
//
// 只要项目里添加并配置了 jackson-databind 依赖，其余什么都不需要做，只要该方法的参数是 Java 对象或 Map，Spring 框架就会自动把客户端请求体的 JSON 字符串转为 Java 对象或 Map
@PostMapping("/test06")
@ResponseBody
// 使用 @RequestBody 注解获取参数
public String test06(@RequestBody Map<String, Object> params) {
    return "test06 success = " + params.get("ids");
}
```

## 三、补充：get 请求、post 请求的请求参数乱码处理

在 web.xml 文件里加上一个字符编码过滤器即可：

```xml
<!-- 字符编码过滤器，用来处理 HTTP 请求的字符编码 -->
<filter>
    <!-- 过滤器的名字，这个名字是我们自己起的，后面在 filter-mapping 中会用到 -->
    <filter-name>characterEncodingFilter</filter-name>
    <!-- 过滤器的实现类，使用 Spring 框架自带的 CharacterEncodingFilter 类 -->
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>

    <!--
        告诉过滤器强制使用 UTF-8 编码来处理请求参数，UTF-8 是目前最通用的字符编码
    -->
    <init-param>
        <param-name>encoding</param-name>
        <param-value>UTF-8</param-value>
    </init-param>
    <init-param>
        <param-name>forceEncoding</param-name>
        <param-value>true</param-value>
    </init-param>
</filter>
<!-- 配置字符编码过滤器的拦截范围，/* 代表会拦截接口型请求 + 静态资源请求 + 动态资源请求所有的 HTTP 请求-->
<filter-mapping>
    <filter-name>characterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

