<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/tx
       http://www.springframework.org/schema/tx/spring-tx.xsd
       http://www.springframework.org/schema/aop
       https://www.springframework.org/schema/aop/spring-aop.xsd">
    <!--
        通过 context:component-scan 标签告诉 Spring 框架哪个包里的类是通过注解实现 IoC 的
        Spring 框架就会扫描这个包里所有有注解的类来自动创建对象并放到 IoC 父容器里

        父容器只需要扫描 service 所在的包即可
    -->
    <context:component-scan base-package="com.ineyee.service"/>


    <!-- =================================数据层 dao 的相关配置================================= -->
    <!-- 1、导入配置文件 -->
    <context:property-placeholder location="classpath:dao.properties"/>

    <!--
        2、开发环境和生产环境的数据库连接池、连接、数据库
            开发阶段，我们可以把默认环境设置为开发环境，从而访问测试数据库
            生产阶段，我们可以把默认环境设置为生产环境，从而访问正式数据库
    -->
    <bean id="devDataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="${dev.driverClassName}"/>
        <property name="url" value="${dev.url}"/>
        <property name="username" value="${dev.username}"/>
        <property name="password" value="${dev.password}"/>
        <property name="initialSize" value="${dev.initialSize}"/>
        <property name="maxActive" value="${dev.maxActive}"/>
    </bean>
    <bean id="prodDataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="${prod.driverClassName}"/>
        <property name="url" value="${prod.url}"/>
        <property name="username" value="${prod.username}"/>
        <property name="password" value="${prod.password}"/>
        <property name="initialSize" value="${prod.initialSize}"/>
        <property name="maxActive" value="${prod.maxActive}"/>
    </bean>

    <!--
        3、之前需要事先创建一个 MyBatisUtil 类来创建 SqlSessionFactory 对象
        现在直接通过 Spring 来创建 SqlSessionFactory 对象

        之前是在 MyBatisUtil 类里创建 SqlSessionFactory 对象的时候通过指定 MyBatis 的配置文件来让 SqlSessionFactory 对象知道 MyBatis 的各种配置
        现在直接通过 SqlSessionFactory 对象的属性即可设置
    -->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <!--
            是否开启驼峰命名自动映射，即数据库表自动转 Java Bean 时是否从经典数据库列名 create_time 映射到经典 Java 属性名 createTime
            默认 false
        -->
        <property name="configuration">
            <bean class="org.apache.ibatis.session.Configuration">
                <property name="mapUnderscoreToCamelCase" value="${mybatis.mapUnderscoreToCamelCase}"/>
            </bean>
        </property>

        <!--
            类型别名 typeAliases，用来给 xml 文件（如 mappers 里的 xml 文件、Spring 的配置文件等）里的类型取别名，如 type、parameterType、resultType 这种以 type 结尾的属性都是接收一个类型
            包名.类名，全类名，比较长；我们可以给全类名取个别名，短类名，比较短，写起来更方便；当然如果你偏好于写全类名，那也可以不定义别名
                方式一：name = 可以是整个包的方式，value = 默认就会把这个包下所有的全类名 com.ineyee.domain.Xxx 取别名为短类名 Xxx
                方式一：name = 也可以是单个类型的方式，value = 默认就会把这个全类名 com.ineyee.domain.Xxx 取别名为短类名 Xxx
        -->
        <property name="typeAliasesPackage" value="${mybatis.typeAliasesPackage}"/>

        <!-- 插件 -->
        <property name="plugins">
            <list>
                <!-- 拦截器设置为 PageHelper 的 PageInterceptor -->
                <bean class="com.github.pagehelper.PageInterceptor">
                    <property name="properties">
                        <props>
                            <!--
                                reasonable 设置为 true，代表使分页查询合理化：
                                    当 pageNum <= 0 时，自动返回第一页的数据
                                    当 pageNum > totalPage 时，自动返回最后一页的数据
                            -->
                            <prop key="reasonable">true</prop>
                        </props>
                    </property>
                </bean>
            </list>
        </property>

        <!--
            开发环境和生产环境的数据库连接池及连接及数据库
                开发阶段，我们可以把默认环境设置为开发环境，从而访问测试数据库
                生产阶段，我们可以把默认环境设置为生产环境，从而访问正式数据库
        -->
        <property name="dataSource" ref="${mybatis.dataSource}"/>

        <!--
            注册数据库表自动转 Java Bean 的映射文件
            这里我们不需要再一个一个映射文件注册了，直接通配符把所有的映射文件注册即可
        -->
        <property name="mapperLocations">
            <list>
                <value>${mybatis.mapperLocations}</value>
            </list>
        </property>
    </bean>

    <!--
       4、之前需要事先创建一个 MyBatisUtil 类来创建 SqlSessionFactory 对象，然后通过 SqlSessionFactory 对象创建 SqlSession 对象，进而用 SqlSession 对象的 getMapper() 方法自动生成 dao 接口类的实现类的对象
       现在直接在 Spring 的配置文件里配置一下 mapper 扫描器即可

       配置完后我们就可以在代码里通过 applicationContext.getBean("dao 的短类名") 来直接获取到 dao 对象了，连 SqlSession 对象的 getMapper() 方法都不用调用了

       这里就不用写 id 属性了，因为这个扫描器是一创建出来就去创建各种 dao 对象的，我们后续并不需要主动根据 id 获取这个扫描器
   -->
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <!-- 需要先指定一下 SqlSessionFactory 对象，以便能用它创建 SqlSession 对象 -->
        <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/>
        <!--
            然后指定一下 dao 包名即可，相当于自动在当前配置文件里添加了很多 <bean id="XxxDao"/> 来创建一个一个的 dao 对象，并且 bean 标签的 id 就是 dao 的短类名（com.ineyee.dao.XxxDao 里的 XxxDao）
            将来我们需要使用哪个 dao 就能通过 dao 的短类名（即 beanId）直接获取相应的到 dao 对象，连 SqlSession 对象的 getMapper() 方法都不用调用了
        -->
        <property name="basePackage" value="com.ineyee.dao"/>
    </bean>
    <!-- =================================数据层 dao 的相关配置================================= -->

    <!-- =================================业务层 service 的相关配置================================= -->
    <!--
        1、Spring 的事务管理器，用来进行事务管理

        将会被下面的 advice 对象引用
    -->
    <bean id="txMgr" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <!-- 要进行事务管理，肯定得先拿到跟数据库相关的东西，因为事务管理就是决定如何操作数据库嘛 -->
        <property name="dataSource" ref="${mybatis.dataSource}"/>
    </bean>

    <!--
        2、这里是附加代码，传个 transaction-manager 进去代表要搞的是事务管理相关的附加代码（这些附加代码 Spring 已经给我们提供好了，我们只需要配置一下即可）

        将会被下面的切面引用
    -->
    <tx:advice id="advice" transaction-manager="txMgr">
        <!-- attributes 标签里需要写明哪些方法需要切入事务管理的附加代码 -->
        <tx:attributes>
            <!--
                一个 method 标签就是一个方法，会结合切入点表达式所设置的类来共同决定到底是哪个类的哪些方法
                    propagation 属性：指定事务嵌套时的传播行为
                    rollback-for 属性：发生什么异常进行回滚
            -->
            <tx:method name="transfer" rollback-for="Exception"/>
            <!-- * 是通配符，代表以 xxx 开头的方法 -->
            <tx:method name="save*"/>
            <tx:method name="remove*"/>
            <tx:method name="update*"/>
            <tx:method name="get*" propagation="SUPPORTS"/>
            <tx:method name="list*" propagation="SUPPORTS"/>
        </tx:attributes>
    </tx:advice>

    <!-- 3、切面 -->
    <aop:config>
        <!--
            切入点：给哪些类的哪些方法附加代码
            该切入点表示要给 com.ineyee.service 包及其子包里所有类的所有方法都附加代码

            切入 Spring 事务管理代码的话，这里的切入点表达式只约束到类就可以了，具体的方法由上面的 attributes 指定
        -->
        <aop:pointcut id="pointcut" expression="execution(* com.ineyee.service..*(..))"/>
        <!-- 通知：按照切入点【pointcut-ref】的配置把附加代码【advice-ref】给附加上去 -->
        <aop:advisor pointcut-ref="pointcut" advice-ref="advice"/>
    </aop:config>
    <!-- =================================业务层 service的相关配置================================= -->
</beans>