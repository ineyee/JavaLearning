#### 1、添加依赖

首先安装 SpringMVC：

```XML
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>7.0.1</version>
</dependency>
```

然后我们知道 SpringMVC 是对 Servlet API 的封装，所以我们还需要安装 jakarta.servlet-api：

```XML
<dependency>
    <groupId>jakarta.servlet</groupId>
    <artifactId>jakarta.servlet-api</artifactId>
    <version>6.1.0</version>
    <scope>provided</scope>
</dependency>
```

#### 2、在 web.xml 里做一些配置

> 这是非常老旧的配置方法，需要我们手动将 DispatcherServlet 的配置写入 web.xml 文件，这里仅做演示用
>
> Spring Boot 诞生后，在检测到 Spring MVC 的依赖后，会自动地、隐式地为我们配置好 DispatcherServlet，其默认拦截路径就是 "/"，让开发者能专注于写接口的业务代码，这个后面再说

```xml
<!DOCTYPE web-app PUBLIC
        "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
        "http://java.sun.com/dtd/web-app_2_3.dtd" >

<web-app>
    <display-name>Archetype Created Web Application</display-name>

    <!--
        配置主控制器

        配置主控制器为 SpringMVC 自带的 DispatcherServlet，这个 DispatcherServlet 是 SpringMVC 的“大脑”
        所有进入应用的请求都会先经过它，再由它负责分发给相应控制器的方法进行处理，我们可以把它想象成公司的“总机接线员”
    -->
    <servlet>
        <servlet-name>springmvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>

        <!--
            指定 Spring 配置文件的位置

            通过 <init-param> 参数告诉 DispatcherServlet 去哪里加载 Spring 的详细配置（classpath:applicationContext.xml）
            这个配置文件里会定义诸如组件扫描、数据源等具体的 Bean
        -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:applicationContext.xml</param-value>
        </init-param>
    </servlet>

    <!--
        配置主控制器可以拦截哪些请求

        通过 <servlet-mapping> 将 DispatcherServlet 的拦截模式设置为 "/"
        这意味着 DispatcherServlet 会拦截所有的HTTP请求（如 /user, /api/login等），但通常不包括静态资源（如 .js, .css, .jpg）
    -->
    <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

#### 3、创建 Spring 的配置文件，做一些配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd">
    <!--
        通过 context:component-scan 标签告诉 Spring 框架哪个包里的类是通过注解实现 IoC 的
        Spring 框架就会扫描这个包里所有有注解的类来自动创建对象并放到 IoC 容器里
    -->
    <context:component-scan base-package="com.ineyee"/>

    <!--
        DispatcherServlet 虽然拦截到了静态资源
        但是我们不让它处理，而是转交给默认的静态资源 Servlet 走服务器默认的处理
    -->
    <mvc:default-servlet-handler/>
    <!--
        但是添加了 mvc:default-servlet-handler 后又会导致 @Controller 等注解无法处理接口型请求
        所以还得加上 mvc:annotation-driven 注解驱动来保证 @Controller 等注解可以正常处理接口型请求
    -->
    <mvc:annotation-driven/>
</beans>
```

#### 4、创建 controller 层，编写接口

需要首先知道的是，servlet 会自动处理 http 协议的标准错误，比如 404、500 等。也就是说我们服务端开发者不需要关心万一客户端请求了一个服务器上根本不存在的路径时咋办，因为框架会自动返回 404 错误给客户端，我们不需要编写任何代码。因此这就意味着我们服务端开发者只需要关心 http 请求成功（200）时的业务逻辑的错误，比如 token 校验出错、用户名或密码出错等，这些业务逻辑的错误需要我们手动编写代码返回错误信息给客户端。

###### 4.1 方案一：http 响应状态码和业务状态码平级使用

```java
// 方案一：http 响应状态码和业务状态码平级使用，以前用的多，比如
// http 响应状态码：
//     200 代表请求成功
//     404 代表请求路径出错
//     500 代表服务器内部出错
// 业务状态码：
//     900 代表 token 校验出错
//     901 代表用户名或密码出错
//
// 注意：http 协议规定 Status code must be greater than 99 and less than 1000
@PostMapping("/login")
@ResponseBody
public ResponseEntity<String> login(@RequestHeader(value = "token", required = false) String token) {
    if (token == null || !token.equals("qwertyuiop")) {
        return ResponseEntity.status(900).body("token 校验出错");
    } else {
        return ResponseEntity.status(200).body("登录成功");
    }
}
```

###### 4.2 方案二：http 响应状态码和业务状态码分层使用

```java
// 方案二：http 响应状态码和业务状态码分层使用，现在用的多，比如
// http 响应状态码：
//     200 代表请求成功
//     404 代表请求路径出错
//     500 代表服务器内部出错
// 业务状态码：
//     0 代表没有业务逻辑错误
//     -1001 代表 token 校验出错
//     -1002 代表用户名或密码出错
//
// 这种方式的优势在于：
// 1、业务状态码跟 http 标准响应状态码不再平级、而是下级，所以就没有了 99~1000 的限制，可以根据业务量需要随便定义多少个状态码，也不至于跟 http 标准响应状态码冲突
// 2、这种方案理解起来是更合理的，具体地说当服务端返回 404、500 等错误时，是代表 http 请求本身出了问题，根本不会走业务；而当服务器返回业务状态码的错误时，http 请求本身其实还是成功的、会返回 200、这很合理，只是我们的业务逻辑出错了而已；因此业务状态码变成 http 标准响应状态码的下级，是更合理的
// 3、对于我们服务端开发者来说，这种方案编写起代码来其实是更清晰的，具体地说就是 http 标准响应状态码交由框架自动处理，而我们只需要关心业务逻辑的状态码。而业务逻辑的状态码必然发生在 http 标准响应状态码为 200 的情况下，因为如果发生其它 http 标准响应状态码的话压根不会走业务逻辑、直接就拦截下来了。总之这样一来，我们服务端开发者就可以在写代码的时候“无视” http 标准响应状态码、就好像不存在这么一种东西一样，而是全部专注于业务逻辑状态码的编写
@PostMapping("/logout")
@ResponseBody
public ResponseEntity<String> logout(@RequestHeader(value = "token", required = false) String token) {
    if (token == null || !token.equals("qwertyuiop")) {
        return ResponseEntity.ok().body("{\"code\":-1001,\"message\":\"token 校验出错\"}");
    } else {
        return ResponseEntity.ok().body("{\"code\":0,\"message\":\"退出登录成功\"}");
    }
}
```

#### 5、补充：全局处理异常、给客户端响应错误

前面《02-JavaWeb基础：05-ProjectArchitecture》里我们提到过：

* dao 层不负责处理异常，往上抛即可，最终会抛到 controller 层统一处理异常
* service 层不负责处理异常，往上抛即可，最终会抛到 controller 层统一处理异常
* controller 层调用 service 层的 API 时一定要用 try-catch，因为 dao 层和 service 层的异常它们都没处理、都是继续上抛到 controller 层来统一处理的，catch 到异常时就给客户端响应错误，没有错误时就给客户端响应数据

这么做是非常合理的，但是有点麻烦，因为我们的项目里会有很多个 controller，每个 controller 里又会有很多个接口方法。如果要在每个接口方法里都写 try-catch，代码量就会非常大，而且给客户端响应错误的代码非常相似，就会写大量重复的代码。所以我们现在要实现一种新方案：

* controller 层调用 service 层的 API 时直接调用就可以了，不用再 try-catch，如果遇到了系统异常那就把系统异常继续往上抛，如果遇到了业务异常那就主动抛出个业务异常
* controller 层把异常继续往上抛，就会抛给 DispatcherServlet，DispatcherServlet 捕获到异常就会调用我们定义的异常处理器来统一处理异常、给客户端响应错误

```java
@Controller
public class TestController {
    @GetMapping("/test01")
    @ResponseBody
    public void test01() throws Exception {
        // 假设这里是调用 service 层的 API 时，抛出了业务异常
        throw new ServiceException(UserError.USER_ALREADY_EXIST.getCode(), UserError.USER_ALREADY_EXIST.getMessage());
    }

    @GetMapping("/test02")
    @ResponseBody
    public void test02() throws Exception {
        // 假设这里是调用 service 层的 API 时，抛出了系统异常
        throw new ClassNotFoundException("TestClass");
    }
}
```

```java
// 第一步：自定义一个 GlobalExceptionHandler 类
// 用 @ControllerAdvice 注解修饰一下这个类，这个注解有两个用途，一是放到 IoC 容器里，二是通过 AOP 把异常处理代码切入到 controller 层的方法里
@ControllerAdvice
public class GlobalExceptionHandler {
    // 第二步：自定义一个方法
    // 用 @ExceptionHandler 注解修饰一下这个方法，表明这个方法专门用来处理 ServiceException 业务异常
    // 这里是业务异常 ServiceException，业务异常各有各的错误码和错误信息，用户在客户端看到错误信息是有提示意义的
    @ExceptionHandler(ServiceException.class)
    @ResponseBody
    public Response handleServiceException(ServiceException e) {
        // 给客户端响应错误
        Response response = new Response();
        response.setCode(e.getCode());
        response.setMessage(e.getMessage());
        return response;
    }

    // 这个方法专门用来处理业务异常以外的系统异常
    // 这里是系统异常 Exception，系统异常是没有 code 的，而且系统异常五花八门、我们也不知道它们什么时候会抛出、抛出的错误信息对用户来说也没有提示意义
    // 所以我们把系统异常的错误码统一为 -100000，错误信息统一为请求失败
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public Response handleException(Exception e) {
        // 给客户端响应错误
        Response response = new Response();
        response.setCode(-100000);
        response.setMessage("请求失败");
        return response;
    }
}
```



