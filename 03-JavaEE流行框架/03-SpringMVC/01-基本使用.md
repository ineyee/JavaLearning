## 一、SpringMVC 是什么

之前的 controller 控制器层，我们是直接通过 jakarta.servlet-api 提供的 Servlet API 来实现的，有很多地方很繁琐。

SpringMVC 的全称是 Spring Web MVC、是 Spring 框架的一部分、是位于 controller 控制器层的框架，它是对 Servlet API 的封装，可以大大简化我们的开发代码，所以我们接下来会用 SpringMVC 来实现 controller 控制器层。

## 二、怎么使用 SpringMVC

#### 1、添加依赖

首先安装 SpringMVC：

```XML
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>7.0.1</version>
</dependency>
```

然后我们知道 SpringMVC 是对 Servlet API 的封装，所以我们还需要安装 jakarta.servlet-api：

```XML
<dependency>
    <groupId>jakarta.servlet</groupId>
    <artifactId>jakarta.servlet-api</artifactId>
    <version>6.1.0</version>
    <scope>provided</scope>
</dependency>
```

#### 2、在 web.xml 里做一些配置

> 这是非常老旧的配置方法，需要我们手动将 DispatcherServlet 的配置写入 web.xml 文件，这里仅做演示用
>
> Spring Boot 诞生后，在检测到 Spring MVC 的依赖后，会自动地、隐式地为我们配置好 DispatcherServlet，其默认拦截路径就是 "/"，让开发者能专注于写接口的业务代码，这个后面再说

```xml
<!DOCTYPE web-app PUBLIC
        "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
        "http://java.sun.com/dtd/web-app_2_3.dtd" >

<web-app>
    <display-name>Archetype Created Web Application</display-name>

    <!--
        配置主控制器

        配置主控制器为 SpringMVC 自带的 DispatcherServlet，这个 DispatcherServlet 是 SpringMVC 的“大脑”
        所有进入应用的请求都会先经过它，再由它负责分发给相应控制器的方法进行处理，我们可以把它想象成公司的“总机接线员”
    -->
    <servlet>
        <!-- 主控制器的名字，这个名字是我们自己起的，后面在 servlet-mapping 中会用到 -->
        <servlet-name>springmvc</servlet-name>
        <!-- 主控制器的实现类，使用 SpringMVC 自带的 DispatcherServlet 类 -->
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>

        <!--
            指定 Spring 配置文件的位置

            通过 <init-param> 参数告诉 DispatcherServlet 去哪里加载 Spring 的配置文件（classpath:applicationContext.xml）
        -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:applicationContext.xml</param-value>
        </init-param>
    </servlet>

    <!--
        配置主控制器可以拦截哪些请求，注意还需配合 Spring 配置文件里的 <mvc:default-servlet-handler/> 和 <mvc:annotation-driven/> 一起使用

        通过 <servlet-mapping> 将 DispatcherServlet 的拦截模式设置为 "/"，这意味着 DispatcherServlet 会拦截接口型请求，会拦截静态资源型请求，不会拦截动态资源型请求（拦截 2 个）
    -->
    <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

#### 3、创建 Spring 的配置文件，做一些配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd">
    <!--
        通过 context:component-scan 标签告诉 Spring 框架哪个包里的类是通过注解实现 IoC 的
        Spring 框架就会扫描这个包里所有有注解的类来自动创建对象并放到 IoC 容器里
    -->
    <context:component-scan base-package="com.ineyee"/>

    <!--
        DispatcherServlet 虽然拦截到了静态资源
        但是我们不让它处理，而是转交给默认的静态资源 Servlet 走服务器默认的处理
    -->
    <mvc:default-servlet-handler/>
    <!--
        但是添加了 mvc:default-servlet-handler 后又会导致 @Controller 等注解无法处理接口型请求
        所以还得加上 mvc:annotation-driven 注解驱动来保证 @Controller 等注解可以正常处理接口型请求
    -->
    <mvc:annotation-driven/>
</beans>
```

#### 4、创建 controller 层，编写接口

我们不再需要像之前那样：

* 第一步：创建一个 XxxServlet 类，继承自 HttpServlet
* 第二步：用 @WebServlet(path) 指定请求路径 path
* 第三步：重写 doGet、doPost 方法监听来自客户端的请求并返回响应

而是：

* 第一步：创建一个 controller 类，不需要继承自任何父类
* 第二步：用 @Controller 注解修饰一下这个类，以便 Spring 框架能自动创建一个该类的对象并放到 IoC 容器里
* 第三步：定义一个方法，这个方法就是一个接口
  * 用 @RequestMapping(path = requestPath, method = requestMethod) 注解修饰这个方法来指定请求路径和请求方法，以便 Spring 框架能把来自客户端的请求精准分发到该方法
  * 用 @ResponseBody 注解修饰一下这个方法，这样一来 Spring 框架就会自动把该方法的返回值作为响应体返回给客户端并结束本次请求了

```java
// 第一步：创建一个 controller 类，不需要继承自任何父类
// 约定俗成地我们会把这个类命名为 XxxController
//
// 第二步：用 @Controller 注解修饰一下这个类，以便 Spring 框架能自动创建一个该类的对象并放到 IoC 容器里
// 对象默认的 beanId 就是它所属类名的第一个字母变成小写（即 loginController），当然我们也可以通过 value 属性来自定义 beanId（value 属性名可以省略不写，直接写值）
@Controller
public class LoginController {
    // 第三步：定义一个方法，这个方法就是一个接口
    // 用 @RequestMapping(path = requestPath, method = requestMethod) 注解修饰这个方法来指定请求路径和请求方法，以便 Spring 框架能把来自客户端的请求精准分发到该方法
    //     path 属性用来指定请求路径，注意 / 不能少
    //     method 属性用来指定请求方法
    // 用 @ResponseBody 注解修饰一下这个方法，这样一来 Spring 框架就会自动把该方法的返回值作为响应体返回给客户端并结束本次请求了
    @RequestMapping(path = "/login", method = RequestMethod.GET)
    @ResponseBody
    public String login1() {
        return "get success";
    }

    @RequestMapping(path = "/login", method = RequestMethod.POST)
    @ResponseBody
    public String login2() {
        return "post success";
    }
}
```

> 整体工作流程总结：
>
> * JavaWeb 项目在 Tomcat 等 Servlet 容器中启动
> * 容器会读取 web.xml 文件，创建并初始化 DispatcherServlet
> * DispatcherServlet 会根据配置加载 applicationContext.xml 文件，创建 Spring 容器及各个 controller 层的 bean 对象
> * 此后，所有来自客户端的请求都会首先经过 DispatcherServlet
> * DispatcherServlet 会根据请求路径和请求方法，找到 @Controller 中具体的方法执行，最后返回响应给客户端

## 三、补充：配置主控制器可以拦截哪些请求

HTTP 请求按资源类型分为三种：

* 接口型请求（如 /login）
* 静态资源型请求（如 .html、.png）
* 动态资源型请求（如 .jsp）

这里所谓的“拦截”是指进入应用的哪些请求会先经过 DispatcherServlet，再由它负责分发给相应控制器的方法进行处理，我们期望的肯定是只拦截接口型请求，因为只有接口型请求才需要我们开发者自定义处理，其它两种请求按照服务器默认的处理就可以了。而 url-pattern 标签的取值一般有三种：

* /*：会拦截接口型请求 + 会拦截静态资源型请求 + 会拦截动态资源型请求（拦截 3 个）
  * /* 啥都会拦截，所以我们肯定不用它

* /：会拦截接口型请求 + 会拦截静态资源型请求 + 不会拦截动态资源型请求（拦截 2 个）
  * / 会拦截接口型请求、不会拦截动态资源型请求，这是满足我们期望的，但是它也会拦截静态资源型请求，这是不满足我们期望的，所以我们得在使用它的前提下，再搞一下它对静态资源型请求的处理
* *.do：会拦截接口型请求 + 不会拦截静态资源型请求 + 不会拦截动态资源型请求（拦截 1 个）
  * *.do 是指我们在编写每个接口的时候，都强制要求手动在路径结尾加上一个 .do，比如 /login.do、/logout.do，这样一来所有的接口型请求就肯定是以 .do 结尾了，而其它两种请求肯定是不以 .do 结尾，就能顺利过滤出来了，有的公司就是这么做的，可以是可以，但每个接口都得加个 .do，也有点麻烦，所以我们可以根据自己的情况看要不要用它

实际开发中我们主要还是用 /，但是用 / 的话除了需要在 web.xml 里做一些配置，还需要在 Spring 配置文件里做一些配置：

```xml
<!--
    配置主控制器可以拦截哪些请求，注意还需配合 Spring 配置文件里的 <mvc:default-servlet-handler/> 和 <mvc:annotation-driven/> 一起使用

    通过 <servlet-mapping> 将 DispatcherServlet 的拦截模式设置为 "/"，这意味着 DispatcherServlet 会拦截接口型请求，会拦截静态资源型请求，不会拦截动态资源型请求（拦截 2 个）
-->
<servlet-mapping>
    <servlet-name>springmvc</servlet-name>
    <url-pattern>/</url-pattern>
</servlet-mapping>
```

```xml
<!--
    DispatcherServlet 虽然拦截到了静态资源
    但是我们不让它处理，而是转交给默认的静态资源 Servlet 走服务器默认的处理
-->
<mvc:default-servlet-handler/>
<!--
    但是添加了 mvc:default-servlet-handler 后又会导致 @Controller 等注解无法处理接口型请求
    所以还得加上 mvc:annotation-driven 注解驱动来保证 @Controller 等注解可以正常处理接口型请求
-->
<mvc:annotation-driven/>
```

