#### 1、添加依赖

首先安装 SpringMVC：

```XML
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>7.0.1</version>
</dependency>
```

然后我们知道 SpringMVC 是对 Servlet API 的封装，所以我们还需要安装 jakarta.servlet-api：

```XML
<dependency>
    <groupId>jakarta.servlet</groupId>
    <artifactId>jakarta.servlet-api</artifactId>
    <version>6.1.0</version>
    <scope>provided</scope>
</dependency>
```

#### 2、在 web.xml 里做一些配置

> 这是非常老旧的配置方法，需要我们手动将 DispatcherServlet 的配置写入 web.xml 文件，这里仅做演示用
>
> Spring Boot 诞生后，在检测到 Spring MVC 的依赖后，会自动地、隐式地为我们配置好 DispatcherServlet，其默认拦截路径就是 "/"，让开发者能专注于写接口的业务代码，这个后面再说

```xml
<!DOCTYPE web-app PUBLIC
        "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
        "http://java.sun.com/dtd/web-app_2_3.dtd" >

<web-app>
    <display-name>Archetype Created Web Application</display-name>

    <!--
        配置主控制器

        配置主控制器为 SpringMVC 自带的 DispatcherServlet，这个 DispatcherServlet 是 SpringMVC 的“大脑”
        所有进入应用的请求都会先经过它，再由它负责分发给相应控制器的方法进行处理，我们可以把它想象成公司的“总机接线员”
    -->
    <servlet>
        <servlet-name>springmvc</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>

        <!--
            指定 Spring 配置文件的位置

            通过 <init-param> 参数告诉 DispatcherServlet 去哪里加载 Spring 的详细配置（classpath:applicationContext.xml）
            这个配置文件里会定义诸如组件扫描、数据源等具体的 Bean
        -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:applicationContext.xml</param-value>
        </init-param>
    </servlet>

    <!--
        配置主控制器可以拦截哪些请求

        通过 <servlet-mapping> 将 DispatcherServlet 的拦截模式设置为 "/"
        这意味着 DispatcherServlet 会拦截所有的HTTP请求（如 /user, /api/login等），但通常不包括静态资源（如 .js, .css, .jpg）
    -->
    <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

#### 3、创建 Spring 的配置文件，做一些配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd">
    <!--
        通过 context:component-scan 标签告诉 Spring 框架哪个包里的类是通过注解实现 IoC 的
        Spring 框架就会扫描这个包里所有有注解的类来自动创建对象并放到 IoC 容器里
    -->
    <context:component-scan base-package="com.ineyee"/>
</beans>
```

#### 4、创建 controller 层，编写接口

* 响应体是普通文本

```xml
<!-- 在 spring 配置文件里统一配置一下当响应体为 String 时的编码方式 -->
<mvc:annotation-driven>
    <mvc:message-converters>
        <bean class="org.springframework.http.converter.StringHttpMessageConverter">
            <property name="defaultCharset" value="utf-8"/>
        </bean>
    </mvc:message-converters>
</mvc:annotation-driven>
```

```java
// 响应体是普通文本
// 用 produces 告诉客户端响应体的格式为普通文本
// 用 @ResponseBody 注解修饰一下这个方法，这样一来 Spring 框架就会自动把该方法的返回值作为响应体返回给客户端并结束本次请求了
@GetMapping(value = "/testPlain", produces = "text/plain")
@ResponseBody
public String testPlain() {
    return "<h1>登录成功<h1>";
}
```

* 响应体是 HTML 文本

```xml
<!-- 在 spring 配置文件里统一配置一下当响应体为 String 时的编码方式 -->
<mvc:annotation-driven>
    <mvc:message-converters>
        <bean class="org.springframework.http.converter.StringHttpMessageConverter">
            <property name="defaultCharset" value="utf-8"/>
        </bean>
    </mvc:message-converters>
</mvc:annotation-driven>
```

```java
// 响应体是 HTML 文本
// 用 produces 告诉客户端响应体的格式为 HTML 文本
// 用 @ResponseBody 注解修饰一下这个方法，这样一来 Spring 框架就会自动把该方法的返回值作为响应体返回给客户端并结束本次请求了
@GetMapping(value = "/testHtml", produces = "text/html")
@ResponseBody
public String testHtml() {
    return "<h1>登录成功<h1>";
}
```

* 响应体是 JSON 字符串

```xml
<!-- 首先在 pom.xml 里添加 Java 对象和 Json 字符串互转的库 -->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.15.2</version>
</dependency>
```

```xml
<!--
	然后在 spring 配置文件里添加互转库的配置
  以及统一配置一下当响应体为 Java 对象时的编码方式（最终会转化为 JSON 字符串）
-->
<mvc:annotation-driven>
    <mvc:message-converters>
        <bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter">
            <property name="defaultCharset" value="utf-8"/>
        </bean>
    </mvc:message-converters>
</mvc:annotation-driven>
```

```java
// 响应体是 JSON 字符串
// 用 produces 告诉客户端响应体的格式为 JSON 字符串
// 用 @ResponseBody 注解修饰一下这个方法，这样一来 Spring 框架就会自动把该方法的返回值作为响应体返回给客户端并结束本次请求了
// 只要项目里添加并配置了 jackson-databind 依赖，其余什么都不需要做，Spring 框架就会自动把该方法的返回值转为 JSON 字符串并返回给客户端了，因此我们只需要直接返回 Java 对象即可
@GetMapping(value = "/testJson", produces = "application/json")
@ResponseBody
public Response testJson() {
    Dog dog1 = new Dog();
    dog1.setName("旺财");
    Dog dog2 = new Dog();
    dog2.setName("二哈");

    Person person = new Person();
    person.setName("张三");
    person.setAge(18);
    person.setHeight(1.88);
    person.setDogList(List.of(dog1, dog2));

    Response response = new Response();
    response.setCode(0);
    response.setMessage("success");
    response.setData(person);

    return response;
}
```

