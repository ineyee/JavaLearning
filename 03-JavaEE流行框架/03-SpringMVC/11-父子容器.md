#### 1、添加依赖

首先安装 SpringMVC：

```XML
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>7.0.1</version>
</dependency>
```

然后我们知道 SpringMVC 是对 Servlet API 的封装，所以我们还需要安装 jakarta.servlet-api：

```XML
<dependency>
    <groupId>jakarta.servlet</groupId>
    <artifactId>jakarta.servlet-api</artifactId>
    <version>6.1.0</version>
    <scope>provided</scope>
</dependency>
```

#### 3、创建 Spring 的配置文件，做一些配置

之前我们是只创建一个 Spring 的配置文件 applicationContext.xml，这就意味着项目里所有的 bean 都存储在同一个 IoC 容器里。而“项目里所有的 bean 都存储在同一个 IoC 容器里”会带来一个问题，那就是无法避免 service 自动注入 controller 这类问题。具体地说，我们项目里 controller 层会自动注入 service，service 层会自动注入 dao，这是非常合理的写法，但是如果我们在 service 层里自动注入了 controller 竟然也不会报错（dao 层里不可能自动注入 service，因为 dao 是用 xml 实现的而不是 Java 代码），这是非常离谱的写法。

所以我们就可以创建两个 Spring 的配置文件，其中一个是主配置文件 applicationContext.xml，另外一个是子配置文件 dispatcherServlet.xml，这就意味着项目里有两个 IoC 容器，并且 Spring 已经默认给我们配置好了两个容器间的父子关系，子容器里可以访问父容器里的东西，父容器里无法访问子容器里的东西。子容器就是专门给 SpringMVC 准备的，所以它里面一般就是用来存储 controller 相关、SpringMVC 特有的一些 bean，因此它只需要扫描 controller 所在的包即可，而主容器就是原来的那个通用容器，所以它里面一般就是用来存储 service 相关、dao 相关、跟 SpringMVC 无关的一些 bean，因此它只需要扫描 service 所在包即可（dao 放到 IoC 容器里不是靠 component-scan 而是靠 MapperScannerConfigurer）。

* applicationContext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd">
    <!--
        通过 context:component-scan 标签告诉 Spring 框架哪个包里的类是通过注解实现 IoC 的
        Spring 框架就会扫描这个包里所有有注解的类来自动创建对象并放到 IoC 父容器里

        父容器只需要扫描 service 所在的包即可
    -->
    <context:component-scan base-package="com.ineyee.service"/>
</beans>
```

* dispatcherServlet.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/mvc
       https://www.springframework.org/schema/mvc/spring-mvc.xsd">
    <!--
        通过 context:component-scan 标签告诉 SpringMVC 框架哪个包里的 Controller 类是通过注解实现 IoC 的
        SpringMVC 框架就会扫描这个包里所有有注解的类来自动创建对象并放到 IoC 子容器里

        子容器只需要扫描 controller 所在的包即可
    -->
    <context:component-scan base-package="com.ineyee.controller"/>

    <!--
        DispatcherServlet 虽然拦截到了静态资源
        但是我们不让它处理，而是转交给默认的静态资源 Servlet 走服务器默认的处理
    -->
    <mvc:default-servlet-handler/>
    <!--
        但是添加了 mvc:default-servlet-handler 后又会导致 @Controller 等注解无法处理接口型请求
        所以还得加上 mvc:annotation-driven 注解驱动来保证 @Controller 等注解可以正常处理接口型请求
    -->
    <mvc:annotation-driven/>
</beans>
```

#### 2、在 web.xml 里做一些配置

> 这是非常老旧的配置方法，需要我们手动将 DispatcherServlet 的配置写入 web.xml 文件，这里仅做演示用
>
> Spring Boot 诞生后，在检测到 Spring MVC 的依赖后，会自动地、隐式地为我们配置好 DispatcherServlet，其默认拦截路径就是 "/"，让开发者能专注于写接口的业务代码，这个后面再说

之前我们只需要指定 Spring 主配置文件的位置，现在有了子配置文件，就得指定两个配置文件的位置了。

```xml
<!DOCTYPE web-app PUBLIC
        "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
        "http://java.sun.com/dtd/web-app_2_3.dtd" >

<web-app>
    <display-name>Archetype Created Web Application</display-name>

    <!-- 指定 Spring 主配置文件的位置 -->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:applicationContext.xml</param-value>
    </context-param>
    <!-- 用来加载 Spring 主配置文件 -->
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>

    <!--
        配置主控制器

        配置主控制器为 SpringMVC 自带的 DispatcherServlet，这个 DispatcherServlet 是 SpringMVC 的“大脑”
        所有进入应用的请求都会先经过它，再由它负责分发给相应控制器的方法进行处理，我们可以把它想象成公司的“总机接线员”
    -->
    <servlet>
        <!-- 主控制器的名字，这个名字是我们自己起的，后面在 servlet-mapping 中会用到 -->
        <servlet-name>springmvc</servlet-name>
        <!-- 主控制器的实现类，使用 SpringMVC 自带的 DispatcherServlet 类 -->
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>

        <!--
            指定 Spring 子配置文件的位置

            通过 <init-param> 参数告诉 DispatcherServlet 去哪里加载 Spring 的子配置文件（classpath:dispatcherServlet.xml）
        -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:dispatcherServlet.xml</param-value>
        </init-param>
    </servlet>

    <!--
        配置主控制器可以拦截哪些请求，注意还需配合 Spring 配置文件里的 <mvc:default-servlet-handler/> 和 <mvc:annotation-driven/> 一起使用

        通过 <servlet-mapping> 将 DispatcherServlet 的拦截模式设置为 "/"，这意味着 DispatcherServlet 会拦截接口型请求，会拦截静态资源型请求，不会拦截动态资源型请求（拦截 2 个）
    -->
    <servlet-mapping>
        <servlet-name>springmvc</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```





