一个数据库里可以有多张表（表的行号下标是从 0 开始的，表的列号下标是从 1 开始的）

## 一、创建表

> 注意：当表已存在时，创建表会报错，所以要判断存不存在
>
> `建议：每张表里必然存在三个字段：id、create_time、update_time`
>
> `建议：如果表里的某个字段不是枚举那种类型，那就把它直接定义成相应的数据类型；但是如果它是枚举那种类型——即它的值可能是多个枚举值其中之一，那不管这个字段的真实类型是什么，我们推荐的做法都是把这个字段设计成 INT 类型，然后真实类型由客户端自己去处理，因为这样做可以很好地应对国际化。比如手机品牌 brand 这个字段，它的值可能是苹果、华为、小米等多个枚举值其中之一，它的真实类型应该是 VARCHAR(x)，但是如果我们真得把这个字段定义成 VARCHAR(x)，那就只能把苹果、华为、小米等汉字直接存进去，此时万一客户端要做国际化，结果从后台拿到的数据却总是写死的中文，那就难办了。而如果设计成 INT，数据库里存的就是012这样的值（约定好 0 代表苹果、1 代表华为、2 代表小米），客户端请求到 012 再去根据国家展示成不同的语言就很灵活`

```SQL
CREATE TABLE IF NOT EXISTS t_user (
  -- 主键、自增
  id INT PRIMARY KEY AUTO_INCREMENT,
  
  -- 该字段我们定义为非必传，即 DATETIME? 类型而非 DATETIME 类型，因此我们需要提供默认值——当前时间
  -- 只要我们给这个字段提供了默认值，实际开发中就无需再手动给这个字段赋值了，让数据库自动维护即可
  -- 无论服务器所在时区是什么时区，MySQL 在自动维护 DATETIME 类型的字段时默认都存储的是零时区的时间，所以客户端拿到时间后展示时需要手动转换为各个时区对应的时间展示；当然有些数据库 GUI 工具——如 Navicat ——在展示这些零时区的时间时可能会转换为当前时区的时间展示，这个我们不用管它；总之，通过 SQL 语句读取到的时间和返回给客户端的时间肯定是零时区的
  create_time DATETIME DEFAULT(CURRENT_TIMESTAMP),

  -- 该字段我们定义为非必传，即 DATETIME? 类型而非 DATETIME 类型，因此我们需要提供默认值——当前时间；并且我们设置当更新了某条数据的任意字段时，都用最新的当前时间更新一下该字段
  -- 只要我们给这个字段提供了默认值，实际开发中就无需再手动给这个字段赋值了，让数据库自动维护即可
  update_time DATETIME DEFAULT(CURRENT_TIMESTAMP) ON UPDATE CURRENT_TIMESTAMP

  -- 该字段我们定义为必传，即 String 类型而非 String? 类型，因此我们不需要提供默认值
  name VARCHAR(100) NOT NULL,

  -- 该字段我们定义为非必传，即 Int? 类型而非 Int 类型，因此我们需要提供默认值
  age INT DEFAULT(0),

  -- 该字段我们定义为非必传，即 Double? 类型而非 Double 类型，因此我们需要提供默认值
  height DOUBLE DEFAULT(0),

  -- 该字段我们定义为必传，即 String 类型而非 String? 类型，因此我们不需要提供默认值
	-- 该字段还得唯一
  email VARCHAR(100) NOT NULL UNIQUE
);
```

## 二、删除表

> 注意：当表不存在时，删除表会报错，所以要判断存不存在

```SQL
DROP TABLE IF EXISTS t_user;
```

## 三、修改表

> 比如我们的项目已经运行维护一段时间了，表里已经有一堆真实数据了，后续迭代中我们需要修改表的一些信息，而不能删除表重新创建

#### 1、修改表名

```SQL
-- 修改 表 要修改的表名 重命名 为 新表名
ALTER TABLE t_user RENAME TO t_users;
```

#### 2、添加新字段

```SQL
-- 修改 表 要修改的表名 添加 新字段 新字段类型
ALTER TABLE t_users ADD sex TINYINT DEFAULT(0);
```

#### 3、修改字段的数据类型

```SQL
-- 修改 表 要修改的表名 使变形 字段 字段新类型
ALTER TABLE t_users MODIFY id BIGINT;
```

## 补充一：SQL 支持的数据类型

#### 1、数值类型

- **整型**

|    类型     | 占用内存（Byte） |      有符号存储范围       | 无符号存储范围  |              备注              |
| :---------: | :--------------: | :-----------------------: | :-------------: | :----------------------------: |
| **TINYINT** |        1         |        [-128, 127]        |    [0, 255]     | **常用，一般用来表示布尔类型** |
|  SMALLINT   |        2         |      [-32768, 32767]      |   [0, 65535]    |                                |
|  MEDIUMINT  |        3         |    [-8388608, 8388607]    |  [0, 16777215]  |                                |
|   **INT**   |        4         | [-2147483648, 2147483647] | [0, 4294967295] |  **常用，足够表示 9 位数字**   |
| **BIGINT**  |        8         |      [-2^63, 2^63-1]      |   [0, 2^64-1]   |  **常用，足够表示 19 位数字**  |

- **浮点型**

|    类型     | 占用内存（Byte） |                             备注                             |
| :---------: | :--------------: | :----------------------------------------------------------: |
|    FLOAT    |        4         |                                                              |
| **DOUBLE**  |        8         |                           **常用**                           |
| **DECIMAL** |      不一定      | **类似于 Java 里的 BigDecimal，如果涉及到钱的计算，就一定要用DECIMAL** |

#### 2、字符串类型

|      类型      |                             备注                             |
| :------------: | :----------------------------------------------------------: |
|    CHAR(x)     | 定长字符串，x 可以是 [0, 255] 之间的任意值，一旦指定 x，那字符串长度就只能是 x |
| **VARCHAR(x)** | **常用，变长字符串，x 可以是 [0, 65535] 之间的任意值，指定 x 后，字符串长度可以是 [0, x] 之间的任意长度** |
|    **TEXT**    | **常用，用于存储长度特别长的大文本（长度超过 65535 这种）**  |

#### 3、二进制类型

| 类型 |                             备注                             |
| :--: | :----------------------------------------------------------: |
| BLOB | 比如文本、图片、音频、视频等文件的二进制数据直接存储进数据库里时 |

#### 4、日期类型

|     类型     |                             备注                             |
| :----------: | :----------------------------------------------------------: |
|   **DATE**   | **常用、如记录生日等某个具体的日期，只有日期部分、没有时分秒部分，格式为 YYYY-MM-DD，范围为 1000-01-01 到 9999-12-31** |
| **DATETIM**E | **常用、如记录用户注册时间等某个更细节的时间，既有日期部分、也有时分秒部分，格式为 YYYY-MM-DD HH:mm:ss，范围为 1000-01-01 00:00:00 到 9999-12-31 23:59:59** |
|  TIMESTAMP   | 既有日期部分、也有时分秒部分，格式为 YYYY-MM-DD HH:mm:ss，范围为 1970-01-01 00:00:01 到 2038-01-19 03:14:07 |

## 补充二：表约束

#### 1、主键 PRIMARY KEY

在一张表中，必须有一个字段来保证每一条记录都不重复，我们把这个字段就称为主键。主键有如下特点：

- 唯一，就算我们不手动设置 UNIQUE，也会被自动隐式设置成 UNIQUE
- 必传，就算我们不手动设置 NOT NULL，也会被自动隐式设置成 NOT NULL

建议：开发中主键字段应该选择和业务无关的，尽量不要选跟业务有关的字段。比如我们有一个用户表，里面有 name、age、height、email 等字段，email 字段也是唯一且必传的，但是我们不建议把它作为主键，而是搞一个 user_id 这种非业务字段来作为主键

#### 2、自增 AUTO_INCREMENT

某些字段我们希望不用我们自己主动去设置，而是自动递增，那就可以用 AUTO_INCREMENT 来约束，比如主键 id，我们一般不是自己生成插入的，而是让它自动递增，自动递增即确保了唯一性也确保了必传性

#### 3、唯一 UNIQUE

如果我们希望某些字段具备唯一性，就可以用 UNIQUE 来约束，如 email 字段

#### 4、必传 NOT NULL

如果我们希望某些字段必传，就可以用 NOT NULL 来约束，如 email 字段

#### 5、默认值 DEFAULT(x)

必传字段将来肯定会有值，而非必传字段在不赋值时，默认值都是 NULL，所以如果我们不想它们的默认值是 NULL，就可以用 DEFAULT 来约束，这样就可以自定义默认值了，建议给非必传字段提供默认值，除非 NULL 这个值有实际意义

#### 6、外键约束 FOREIGN KEY

如果一张表需要引用另外一张表的数据，一般是用这张表的外键来引用另外一张表的主键

通常情况下，外键应该定义在“多方”的表里而不应该定义在“一方”的表里。所谓“多方”和“一方”是一种逻辑上的关系，比如歌曲表和歌手表，一个歌手可能有多个歌曲，所以歌曲表就是“多方”，歌手表就是“一方”；又比如部门表和员工表，一个部门可能有多个员工，所以员工表就是“多方”，部门表就是“一方”。多方表又称从表、一方表又称主表

总之：一主多从，从带“剑”
