设计表结构时可以按如下思路：

- 第一步确定需要创建几张表：首先根据业务场景确定有多少个对象，进而确定需要创建几张表。比如需要创建歌手表和歌曲表
- 第二步确定多表关系：然后分别从两个方向分析对象间的逻辑关系，进而确定多表关系。比如我们的系统里只收录歌手播放量最高的歌曲，那么在这一场景下，一个歌手只可能`拥有`一首歌曲，一首歌曲也只可能`属于`一个歌手，因此这两张表就是`一对一表结构`；又比如我们的系统里只收录歌手的单唱歌曲，那么在这一场景下，一个歌手可能`拥有`多首歌曲，一首歌曲却只可能`属于`一个歌手，因此这两张表就是`一对多表结构`；又比如我们的系统里只收录歌手的合唱歌曲，那么在这一场景下，一个歌手可能`拥有`多首歌曲，一首歌曲也可能`属于`多个歌手，因此这两张表就是`多对多表结构`
- 第三步确定主表从表、外键写在哪里、先创建哪张表后创建哪张表：一对一表结构时，谁是主表谁是从表都可以，但是建议“拥有者”——歌手——是主表、“属于者”——歌曲——是从表、外键写在从表里；一对多表结构时，一主多从从带剑（键），即一方是主表、多方是从表、外键写在从表里；多对多表结构时，两张表都是主表，需要引入一张中间表来做从表，外键写在从表里；先创建主表后创建从表

本篇我们演示一对多表结构的多表关联和多表查询，即我们的系统里只收录歌手的单唱歌曲这一场景，一个歌手可能拥有多首歌曲，一首歌曲却只可能属于一个歌手。

## 一、多表关联的实现

#### 1、情况一：最初设计表和创建表的时候，我们已经确定好了表与表之间的关系

比如我们设计了如下歌手表（主表）和歌曲表（从表、外键写在从表里）

| id（主键） |  name  | sex  |
| :--------: | :----: | :--: |
|     1      | 周杰伦 |  ''  |
|     2      |  李健  |  男  |
|     3      | 梁静茹 |  女  |

| id（主键） |    name    |       cover        | singer_id（外键） |
| :--------: | :--------: | :----------------: | :---------------: |
|     1      |   七里香   | https://七里香.jpg |         1         |
|     2      |    晴天    |  https://晴天.jpg  |         1         |
|     3      | 贝加尔湖畔 |         ''         |         2         |
|     4      |     画     |   https://画.jpg   |       NULL        |
|     5      |    成都    |  https://成都.jpg  |       NULL        |

那么先创建做为主表的歌手表，再创建做为从表的歌曲表

```SQL
CREATE TABLE IF NOT EXISTS t_singer (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(100) NOT NULL,
  sex VARCHAR(100) DEFAULT('')
);
```

```SQL
CREATE TABLE IF NOT EXISTS t_song (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(100) NOT NULL,
  cover VARCHAR(100) DEFAULT(''),
	
  -- 外键字段，必须与 t_singer.id 类型一致
  singer_id BIGINT,
  -- 在 CREATE 语句的最后添加一个外键约束，含义为：
  -- 当前表中的外键 singer_id，引用的是 t_singer 表中的 id
  -- ON UPDATE 和 ON DELETE 是指当我们修改或删除 t_singer.id 时，t_song 应该做出什么反应，默认情况下这个值是 RESTRICT —— 即如果某个字段被外键关联着、那么在修改或删除这个字段时直接报错、也就是说不允许删除或修改；我们通常会手动设置为 CASCADE —— 即允许修改或删除这个字段、并且如果是修改这个字段那就跟随修改另外一张表里的数据、如果是删除这个字段那就跟随删除另外一张表里的数据
  FOREIGN KEY (singer_id) REFERENCES t_singer(id) ON UPDATE CASCADE ON DELETE CASCADE
);
```

#### 2、情况二：最初设计表和创建表的时候，我们没有确定好表与表之间的关系，后续开发需要补充

比如最初我们只设计和创建了歌曲表

| id（主键） |    name    |       cover        |
| :--------: | :--------: | :----------------: |
|     1      |   七里香   | https://七里香.jpg |
|     2      |    晴天    |  https://晴天.jpg  |
|     3      | 贝加尔湖畔 |         ''         |
|     4      |     画     |   https://画.jpg   |
|     5      |    成都    |  https://成都.jpg  |

```SQL
CREATE TABLE IF NOT EXISTS t_song (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(100) NOT NULL,
  cover VARCHAR(100) DEFAULT('')
);
```

但是随着业务的发展，我们发现需要新增一张歌手表，并将歌曲表和歌手表关联起来，于是我们就设计和创建了一张歌手表

| id（主键） |  name  | sex |
| :--------: | :----: | :-: |
|     1      | 周杰伦 | ''  |
|     2      |  李健  | 男  |
|     3      | 梁静茹 | 女  |

```SQL
CREATE TABLE IF NOT EXISTS t_singer (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(100) NOT NULL,
  sex VARCHAR(100) DEFAULT('')
);
```

等两个表都存在后，将歌曲表和歌手表通过外键关联起来

```SQL
-- 先给歌曲表添加一个外键，必须与 t_singer.id 类型一致
ALTER TABLE t_song ADD singer_id BIGINT;
```

```SQL
-- 然后通过这个外键将两个表关联起来
ALTER TABLE t_song ADD FOREIGN KEY (singer_id) REFERENCES t_singer(id) ON UPDATE CASCADE ON DELETE CASCADE;
```

#### 3、给主表和从表中插入数据

给歌手表中插入数据

```SQL
INSERT INTO t_singer (
	name,
	sex
) VALUES (
	'周杰伦',
	''
);

INSERT INTO t_singer (
	name,
	sex
) VALUES (
	'李健',
	'男'
);

INSERT INTO t_singer (
	name,
	sex
) VALUES (
	'梁静茹',
	'女'
);
```

给歌曲表中插入数据

```SQL
INSERT INTO t_song (
	name,
	cover,
	singer_id
) VALUES (
	'七里香',
	'https://七里香.jpg',
	1
);

INSERT INTO t_song (
	name,
	cover,
	singer_id
) VALUES (
	'晴天',
	'https://晴天.jpg',
	1
);

INSERT INTO t_song (
	name,
	cover,
	singer_id
) VALUES (
	'风吹麦浪',
	'',
	2
);

INSERT INTO t_song (
	name,
	cover,
	singer_id
) VALUES (
	'画',
	'https://画.jpg',
	NULL
);

INSERT INTO t_song (
	name,
	cover,
	singer_id
) VALUES (
	'成都',
	'https://成都.jpg',
	NULL
);
```

## 二、多表查询的实现

> 左连接、右连接、内连接、全连接决定的只是**把哪个表的数据全查出来**，另一个表的数据作为辅助数据
>
> 比如表1左连接表2，那么就是把表1里所有的数据都查出来，而表2里的数据则只会查询出来那些能匹配上表1外键的，匹配不上的会被过滤掉；表1右连接表2，那么就是把表2里所有的数据都查出来，而表1里的数据则只会查询出来那些能匹配上表2主键的，匹配不上的会被过滤掉；而表1左连接表2和表2右连接表1的效果是一样
>
> 对于 SELECT FROM JOIN 这样多表查询的使用，我们可以理解为查询是个串行操作，即先去表1里查询出需要的数据（通过 FROM），然后再根据我们设定的条件遍历第一次查询出来的数据、依次去表2里碰撞查询出需要的数据（通过 JOIN），如果后面还有 JOIN、那就遍历第二次查询出来的数据、依次去表3里碰撞查询出需要的数据，以此类推，最终再整合成我们需要的数据返回给我们

**查询的格式如下：一个 FROM 一个 JOIN**

```SQL
SELECT 字段1, 字段2, ...
FROM 表1
[LEFT | RIGHT | INNER/CROSS | FULL JOIN 表2 ON 表1.外键 = 表2.主键]
[WHERE 查询条件]
[ORDER BY 要按照哪个字段来进行排序 ASC(代表升序) | DESC(代表降序)]
[LIMIT 这一次拿多少条数据 OFFSET 这一次从哪个偏移位置开始拿数据]
```

## 1、左连接（实际开发中用得多）

> 左连接的效果是`以表1为主、表2为辅`，也就是说：
>
> - 肯定会把表1里所有的数据都查询出来，就算表1里某些数据的外键没有匹配上表2里的主键
> - 而表2里的数据则只会查询出来那些能匹配上表1外键的，匹配不上的会被过滤掉

```SQL
SELECT
	-- 这里是在给表1和表2的字段取别名，避免查询结果里的字段名冲突
	-- t_song 的字段对应 FROM t_song，代表是从 t_song 里的查询
  t_song.id AS song_id,
  t_song.name AS song_name,
  t_song.cover AS song_cover,
	-- t_singer 的字段对应 LEFT JOIN t_singer，代表是从 t_singer 里的查询
  t_singer.id AS singer_id,
  t_singer.name AS singer_name,
  t_singer.sex AS singer_sex
-- t_song 是表1
FROM t_song
-- t_singer 是表2，表1.外键 = 表2.主键
LEFT JOIN t_singer ON t_song.singer_id = t_singer.id;
```

查询结果如下，可见：

- 的确把表1——即歌曲表——里所有的数据都查询出来了，就算画和成都这两首歌在表2——即歌手表——里没有匹配的数据
- 而表2里数据只查询出来了匹配到表1的数据，像梁静茹就被过滤掉了

| song_id | song_name  |     song_cover     | singer_id | singer_name | singer_sex |
| :-----: | :--------: | :----------------: | :-------: | :---------: | :--------: |
|    1    |   七里香   | https://七里香.jpg |     1     |   周杰伦    |     ''     |
|    2    |    晴天    |  https://晴天.jpg  |     1     |   周杰伦    |     ''     |
|    3    | 贝加尔湖畔 |         ''         |     2     |    李健     |     男     |
|    4    |     画     |   https://画.jpg   |   NULL    |    NULL     |    NULL    |
|    5    |    成都    |  https://成都.jpg  |   NULL    |    NULL     |    NULL    |

## 2、右连接（实际开发中用得不多）

> 右连接的效果是`以表2为主、表1为辅`，也就是说：
>
> - 肯定会把表2里所有的数据都查询出来，就算表2里某些数据的主键没有匹配上表1的外键
> - 而表1里的数据则只会查询出来那些能匹配上表2主键的，匹配不上的会被过滤掉

```SQL
SELECT
	-- 这里是在给表1和表2的字段取别名，避免查询结果里的字段名冲突
	-- t_song 的字段对应 FROM t_song，代表是从 t_song 里的查询
  t_song.id AS song_id,
  t_song.name AS song_name,
  t_song.cover AS song_cover,
	-- t_singer 的字段对应 LEFT JOIN t_singer，代表是从 t_singer 里的查询
  t_singer.id AS singer_id,
  t_singer.name AS singer_name,
  t_singer.sex AS singer_sex
-- t_song 是表1
FROM t_song
-- t_singer 是表2，表1.外键 = 表2.主键
RIGHT JOIN t_singer ON t_song.singer_id = t_singer.id;
```

查询结果如下：

| song_id | song_name  |     song_cover     | singer_id | singer_name | singer_sex |
| :-----: | :--------: | :----------------: | :-------: | :---------: | :--------: |
|    1    |   七里香   | https://七里香.jpg |     1     |   周杰伦    |     ''     |
|    2    |    晴天    |  https://晴天.jpg  |     1     |   周杰伦    |     ''     |
|    3    | 贝加尔湖畔 |         ''         |     2     |    李健     |     男     |
|  NULL   |    NULL    |        NULL        |     3     |   梁静茹    |     女     |

## 3、内连接（实际开发中用得多）

> 内连接的效果是`同时以表1和表2为主`，也就是说：
>
> - 只会查询出那些表1和表2里表1.外键匹配上表2.主键的数据
> - 不管你是表1还是表2里的数据，只要没匹配上就会被过滤掉

```SQL
SELECT
	-- 这里是在给表1和表2的字段取别名，避免查询结果里的字段名冲突
	-- t_song 的字段对应 FROM t_song，代表是从 t_song 里的查询
  t_song.id AS song_id,
  t_song.name AS song_name,
  t_song.cover AS song_cover,
	-- t_singer 的字段对应 LEFT JOIN t_singer，代表是从 t_singer 里的查询
  t_singer.id AS singer_id,
  t_singer.name AS singer_name,
  t_singer.sex AS singer_sex
-- t_song 是表1
FROM t_song
-- t_singer 是表2，表1.外键 = 表2.主键
INNER JOIN t_singer ON t_song.singer_id = t_singer.id;
```

查询结果如下：

| song_id | song_name  |     song_cover     | singer_id | singer_name | singer_sex |
| :-----: | :--------: | :----------------: | :-------: | :---------: | :--------: |
|    1    |   七里香   | https://七里香.jpg |     1     |   周杰伦    |     ''     |
|    2    |    晴天    |  https://晴天.jpg  |     1     |   周杰伦    |     ''     |
|    3    | 贝加尔湖畔 |         ''         |     2     |    李健     |     男     |

## 4、全连接（实际开发中用得不多）

> 全连接的效果是`同时以表1和表2为主`，也就是说：
>
> - 会查询出表1和表2里所有的数据
> - 一条都不会过滤
>
> SQL 规范中全连接是使用 FULL JOIN，但是 MySQL 中没有实现 FULL JOIN，所以我们需要用“左连接 UNION 右连接”来实现全连接的效果

```SQL
(
  SELECT
    -- 这里是在给表1和表2的字段取别名，避免查询结果里的字段名冲突
    -- t_song 的字段对应 FROM t_song，代表是从 t_song 里的查询
    t_song.id AS song_id,
    t_song.name AS song_name,
    t_song.cover AS song_cover,
    -- t_singer 的字段对应 LEFT JOIN t_singer，代表是从 t_singer 里的查询
    t_singer.id AS singer_id,
    t_singer.name AS singer_name,
    t_singer.sex AS singer_sex
  -- t_song 是表1
  FROM t_song
  -- t_singer 是表2，表1.外键 = 表2.主键
  LEFT JOIN t_singer ON t_song.singer_id = t_singer.id
)
UNION
(
	SELECT
    -- 这里是在给表1和表2的字段取别名，避免查询结果里的字段名冲突
    -- t_song 的字段对应 FROM t_song，代表是从 t_song 里的查询
    t_song.id AS song_id,
    t_song.name AS song_name,
    t_song.cover AS song_cover,
    -- t_singer 的字段对应 LEFT JOIN t_singer，代表是从 t_singer 里的查询
    t_singer.id AS singer_id,
    t_singer.name AS singer_name,
    t_singer.sex AS singer_sex
  -- t_song 是表1
  FROM t_song
  -- t_singer 是表2，表1.外键 = 表2.主键
  RIGHT JOIN t_singer ON t_song.singer_id = t_singer.id
);
```

查询结果如下：

| song_id | song_name  |     song_cover     | singer_id | singer_name | singer_sex |
| :-----: | :--------: | :----------------: | :-------: | :---------: | :--------: |
|    1    |   七里香   | https://七里香.jpg |     1     |   周杰伦    |     ''     |
|    2    |    晴天    |  https://晴天.jpg  |     1     |   周杰伦    |     ''     |
|    3    | 贝加尔湖畔 |         ''         |     2     |    李健     |     男     |
|    4    |     画     |   https://画.jpg   |   NULL    |    NULL     |    NULL    |
|    5    |    成都    |  https://成都.jpg  |   NULL    |    NULL     |    NULL    |
|  NULL   |    NULL    |        NULL        |     3     |   梁静茹    |     女     |
