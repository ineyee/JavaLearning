设计表结构时可以按如下思路：

- 第一步确定需要创建几张表：首先根据业务场景确定有多少个对象，进而确定需要创建几张表。比如需要创建歌手表和歌曲表
- 第二步确定多表关系：然后分别从两个方向分析对象间的逻辑关系，进而确定多表关系。比如我们的系统里只收录歌手播放量最高的歌曲，那么在这一场景下，一个歌手只可能`拥有`一首歌曲，一首歌曲也只可能`属于`一个歌手，因此这两张表就是`一对一表结构`；又比如我们的系统里只收录歌手的单唱歌曲，那么在这一场景下，一个歌手可能`拥有`多首歌曲，一首歌曲却只可能`属于`一个歌手，因此这两张表就是`一对多表结构`；又比如我们的系统里只收录歌手的合唱歌曲，那么在这一场景下，一个歌手可能`拥有`多首歌曲，一首歌曲也可能`属于`多个歌手，因此这两张表就是`多对多表结构`
- 第三步确定主表从表、外键写在哪里、先创建哪张表后创建哪张表：一对一表结构时，谁是主表谁是从表都可以，但是建议“拥有者”——歌手——是主表、“属于者”——歌曲——是从表、外键写在从表里；一对多表结构时，一主多从从带剑（键），即一方是主表、多方是从表、外键写在从表里；多对多表结构时，两张表都是主表，需要引入一张中间表来做从表，外键写在从表里；先创建主表后创建从表

本篇我们演示多对多表结构的多表关联和多表查询，即我们的系统里只收录歌手的合唱歌曲这一场景，一个歌手可能拥有多首歌曲，一首歌曲也可能属于多个歌手。

## 一、多表关联的实现

比如我们设计了如下歌手表（主表）、歌曲表（主表）和中间表（从表、外键写在从表里，中间表包含两个外键，分别指向两个主表的主键）

| id（主键） |  name  | sex |
| :--------: | :----: | :-: |
|     1      | 周杰伦 | ''  |
|     2      |  李健  | 男  |
|     3      | 梁静茹 | 女  |
|     4      |  温岚  | 女  |
|     5      |  孙俪  | 女  |

| id（主键） |   name   |       cover        |
| :--------: | :------: | :----------------: |
|     1      |  七里香  | https://七里香.jpg |
|     2      |   屋顶   |  https://屋顶.jpg  |
|     3      | 风吹麦浪 |         ''         |
|     4      |    画    |   https://画.jpg   |
|     5      |   成都   |  https://成都.jpg  |

| id（主键） | song_id（外键） | singer_id（外键） |
| :--------: | :-------------: | :---------------: |
|     1      |        1        |         1         |
|     2      |        2        |         1         |
|     3      |        2        |         4         |
|     4      |        3        |         2         |
|     5      |        3        |         5         |
|     6      |        4        |       NULL        |
|     7      |        5        |       NULL        |

那么先创建做为主表的歌手表和歌曲表，再创建做为从表的中间表

```SQL
CREATE TABLE IF NOT EXISTS t_singer (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(100) NOT NULL,
  sex VARCHAR(100) DEFAULT('')
);
```

```SQL
CREATE TABLE IF NOT EXISTS t_song (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(100) NOT NULL,
  cover VARCHAR(100) DEFAULT('')
);
```

```SQL
CREATE TABLE IF NOT EXISTS t_singer_song (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
	
	-- 外键字段，必须与 t_singer.id 类型一致
	singer_id BIGINT,
	-- 外键字段，必须与 t_song.id 类型一致
  song_id BIGINT,
	-- 在 CREATE 语句的最后添加一个外键约束，含义为：
  -- 当前表中的外键 singer_id，引用的是 t_singer 表中的 id
  -- ON UPDATE 和 ON DELETE 是指当我们修改或删除 t_singer.id 时，t_singer_song 应该做出什么反应，默认情况下这个值是 RESTRICT —— 即如果某个字段被外键关联着、那么在修改或删除这个字段时直接报错、也就是说不允许删除或修改；我们通常会手动设置为 CASCADE —— 即允许修改或删除这个字段、并且如果是修改这个字段那就跟随修改另外一张表里的数据、如果是删除这个字段那就跟随删除另外一张表里的数据
	FOREIGN KEY (singer_id) REFERENCES t_singer(id) ON UPDATE CASCADE ON DELETE CASCADE,
  FOREIGN KEY (song_id) REFERENCES t_song(id) ON UPDATE CASCADE ON DELETE CASCADE
);
```

给歌手表中插入数据

```SQL
INSERT INTO t_singer (
	name,
	sex
) VALUES (
	'周杰伦',
	''
);

INSERT INTO t_singer (
	name,
	sex
) VALUES (
	'李健',
	'男'
);

INSERT INTO t_singer (
	name,
	sex
) VALUES (
	'梁静茹',
	'女'
);

INSERT INTO t_singer (
	name,
	sex
) VALUES (
	'温岚',
	'女'
);

INSERT INTO t_singer (
	name,
	sex
) VALUES (
	'孙俪',
	'女'
);
```

给歌曲表中插入数据

```SQL
INSERT INTO t_song (
	name,
	cover
) VALUES (
	'七里香',
	'https://七里香.jpg'
);

INSERT INTO t_song (
	name,
	cover
) VALUES (
	'屋顶',
	'https://屋顶.jpg'
);

INSERT INTO t_song (
	name,
	cover
) VALUES (
	'风吹麦浪',
	''
);

INSERT INTO t_song (
	name,
	cover
) VALUES (
	'画',
	'https://画.jpg'
);

INSERT INTO t_song (
	name,
	cover
) VALUES (
	'成都',
	'https://成都.jpg'
);
```

给中间表中插入数据

```SQL
INSERT INTO t_singer_song (
	song_id,
	singer_id
) VALUES (
	1,
	1
);

INSERT INTO t_singer_song (
	song_id,
	singer_id
) VALUES (
	2,
	1
);

INSERT INTO t_singer_song (
	song_id,
	singer_id
) VALUES (
	2,
	4
);

INSERT INTO t_singer_song (
	song_id,
	singer_id
) VALUES (
	3,
	2
);

INSERT INTO t_singer_song (
	song_id,
	singer_id
) VALUES (
	3,
	5
);

INSERT INTO t_singer_song (
	song_id,
	singer_id
) VALUES (
	4,
	NULL
);

INSERT INTO t_singer_song (
	song_id,
	singer_id
) VALUES (
	5,
	NULL
);
```

## 二、多表查询的实现

> 左连接、右连接、内连接、全连接决定的只是**把哪个表的数据全查出来**，另一个表的数据作为辅助数据
>
> 比如表1左连接表2，那么就是把表1里所有的数据都查出来，而表2里的数据则只会查询出来那些能匹配上表1外键的，匹配不上的会被过滤掉；表1右连接表2，那么就是把表2里所有的数据都查出来，而表1里的数据则只会查询出来那些能匹配上表2主键的，匹配不上的会被过滤掉；而表1左连接表2和表2右连接表1的效果是一样
>
> 对于 SELECT FROM JOIN 这样多表查询的使用，我们可以理解为查询是个串行操作，即先去表1里查询出需要的数据（通过 FROM），然后再根据我们设定的条件遍历第一次查询出来的数据、依次去表2里碰撞查询出需要的数据（通过 JOIN），如果后面还有 JOIN、那就遍历第二次查询出来的数据、依次去表3里碰撞查询出需要的数据，以此类推，最终再整合成我们需要的数据返回给我们

**查询的格式如下：一个 FROM 两个 JOIN**

```SQL
SELECT 字段1, 字段2, ...
FROM 表1
[LEFT | RIGHT | INNER/CROSS | FULL JOIN 中间表 ON 中间表.外键 = 表1.主键]
[LEFT | RIGHT | INNER/CROSS | FULL JOIN 表2 ON 中间表.外键 = 表2.主键]
[WHERE 查询条件]
[ORDER BY 要按照哪个字段来进行排序 ASC(代表升序) | DESC(代表降序)]
[LIMIT 这一次拿多少条数据 OFFSET 这一次从哪个偏移位置开始拿数据]
```

## 1、左连接（实际开发中用得多）

> 左连接的效果是`以主表1为主、主表2为辅`，也就是说：
>
> - 肯定会把主表1里所有的数据都查询出来，就算主表1里某些数据没有匹配上主表2里的数据，即会查询出来所有的歌曲、但是歌手就可能会被过滤了
> - 而主表2里的数据则只会查询出来那些能匹配上主表1的，匹配不上的会被过滤掉

```SQL
SELECT
	-- 这里是在给表1和表2的字段取别名，避免查询结果里的字段名冲突
	-- t_song 的字段对应 FROM t_song，代表是从 t_song 里的查询
  t_song.id AS song_id,
  t_song.name AS song_name,
  t_song.cover AS song_cover,
	-- t_singer 的字段对应 LEFT JOIN t_singer，代表是从 t_singer 里的查询
  t_singer.id AS singer_id,
  t_singer.name AS singer_name,
  t_singer.sex AS singer_sex
-- t_song 是主表1
FROM t_song
-- t_singer_song 是中间表，中间表.外键 = 表1.主键
LEFT JOIN t_singer_song ON t_singer_song.song_id = t_song.id
-- t_singer 是主表2，中间表.外键 = 表2.主键
LEFT JOIN t_singer ON t_singer_song.singer_id = t_singer.id;
```

查询结果如下：

| song_id | song_name |     song_cover     | singer_id | singer_name | singer_sex |
| :-----: | :-------: | :----------------: | :-------: | :---------: | :--------: |
|    1    |  七里香   | https://七里香.jpg |     1     |   周杰伦    |     ''     |
|    2    |   屋顶    |  https://屋顶.jpg  |     4     |    温岚     |     女     |
|    2    |   屋顶    |  https://屋顶.jpg  |     1     |   周杰伦    |     ''     |
|    3    | 风吹麦浪  |                    |     5     |    孙俪     |     女     |
|    3    | 风吹麦浪  |                    |     2     |    李健     |     男     |
|    4    |    画     |   https://画.jpg   |   NULL    |    NULL     |    NULL    |
|    5    |   成都    |  https://成都.jpg  |   NULL    |    NULL     |    NULL    |

## 2、右连接（实际开发中用得不多）

> 右连接的效果是`以主表2为主、主表1为辅`，也就是说：
>
> - 肯定会把主表2里所有的数据都查询出来，就算主2里某些数据没有匹配上主表1里的数据，即会查询出来所有的歌手、但是歌曲就可能会被过滤了
> - 而主表1里的数据则只会查询出来那些能匹配上主表2的，匹配不上的会被过滤掉

```SQL
SELECT
	-- 这里是在给表1和表2的字段取别名，避免查询结果里的字段名冲突
	-- t_song 的字段对应 FROM t_song，代表是从 t_song 里的查询
  t_song.id AS song_id,
  t_song.name AS song_name,
  t_song.cover AS song_cover,
	-- t_singer 的字段对应 LEFT JOIN t_singer，代表是从 t_singer 里的查询
  t_singer.id AS singer_id,
  t_singer.name AS singer_name,
  t_singer.sex AS singer_sex
-- t_song 是主表1
FROM t_song
-- t_singer_song 是中间表，中间表.外键 = 表1.主键
RIGHT JOIN t_singer_song ON t_singer_song.song_id = t_song.id
-- t_singer 是主表2，中间表.外键 = 表2.主键
RIGHT JOIN t_singer ON t_singer_song.singer_id = t_singer.id;
```

查询结果如下：

| song_id | song_name |     song_cover     | singer_id | singer_name | singer_sex |
| :-----: | :-------: | :----------------: | :-------: | :---------: | :--------: |
|    1    |  七里香   | https://七里香.jpg |     1     |   周杰伦    |     ''     |
|    2    |   屋顶    |  https://屋顶.jpg  |     1     |   周杰伦    |     ''     |
|    3    | 风吹麦浪  |                    |     2     |    李健     |     男     |
|  NULL   |   NULL    |        NULL        |     3     |   梁静茹    |     女     |
|    2    |   屋顶    |  https://屋顶.jpg  |     4     |    温岚     |     女     |
|    3    | 风吹麦浪  |                    |     5     |    孙俪     |     女     |

## 3、内连接（实际开发中用得多）

> 内连接的效果是`同时以主表1和主表2为主`，也就是说：
>
> - 只会查询出那些主表1和主表2里匹配上的数据
> - 只要没匹配上就会被过滤掉

```SQL
SELECT
	-- 这里是在给表1和表2的字段取别名，避免查询结果里的字段名冲突
	-- t_song 的字段对应 FROM t_song，代表是从 t_song 里的查询
  t_song.id AS song_id,
  t_song.name AS song_name,
  t_song.cover AS song_cover,
	-- t_singer 的字段对应 LEFT JOIN t_singer，代表是从 t_singer 里的查询
  t_singer.id AS singer_id,
  t_singer.name AS singer_name,
  t_singer.sex AS singer_sex
-- t_song 是主表1
FROM t_song
-- t_singer_song 是中间表，中间表.外键 = 表1.主键
INNER JOIN t_singer_song ON t_singer_song.song_id = t_song.id
-- t_singer 是主表2，中间表.外键 = 表2.主键
INNER JOIN t_singer ON t_singer_song.singer_id = t_singer.id;
```

查询结果如下：

| song_id | song_name |     song_cover     | singer_id | singer_name | singer_sex |
| :-----: | :-------: | :----------------: | :-------: | :---------: | :--------: |
|    1    |  七里香   | https://七里香.jpg |     1     |   周杰伦    |     ''     |
|    2    |   屋顶    |  https://屋顶.jpg  |     4     |    温岚     |     女     |
|    2    |   屋顶    |  https://屋顶.jpg  |     1     |   周杰伦    |     ''     |
|    3    | 风吹麦浪  |                    |     5     |    孙俪     |     女     |
|    3    | 风吹麦浪  |                    |     2     |    李健     |     男     |

## 4、全连接（实际开发中用得不多）

> 全连接的效果是`同时以表1和表2为主`，也就是说：
>
> - 会查询出表1和表2里所有的数据
> - 一条都不会过滤
>
> SQL 规范中全连接是使用 FULL JOIN，但是 MySQL 中没有实现 FULL JOIN，所以我们需要用“左连接 UNION 右连接”来实现全连接的效果

```SQL
(
  SELECT
    -- 这里是在给表1和表2的字段取别名，避免查询结果里的字段名冲突
    -- t_song 的字段对应 FROM t_song，代表是从 t_song 里的查询
    t_song.id AS song_id,
    t_song.name AS song_name,
    t_song.cover AS song_cover,
    -- t_singer 的字段对应 LEFT JOIN t_singer，代表是从 t_singer 里的查询
    t_singer.id AS singer_id,
    t_singer.name AS singer_name,
    t_singer.sex AS singer_sex
  -- t_song 是主表1
  FROM t_song
  -- t_singer_song 是中间表，中间表.外键 = 表1.主键
  LEFT JOIN t_singer_song ON t_singer_song.song_id = t_song.id
  -- t_singer 是主表2，中间表.外键 = 表2.主键
  LEFT JOIN t_singer ON t_singer_song.singer_id = t_singer.id
)
UNION
(
  SELECT
    -- 这里是在给表1和表2的字段取别名，避免查询结果里的字段名冲突
    -- t_song 的字段对应 FROM t_song，代表是从 t_song 里的查询
    t_song.id AS song_id,
    t_song.name AS song_name,
    t_song.cover AS song_cover,
    -- t_singer 的字段对应 LEFT JOIN t_singer，代表是从 t_singer 里的查询
    t_singer.id AS singer_id,
    t_singer.name AS singer_name,
    t_singer.sex AS singer_sex
  -- t_song 是主表1
  FROM t_song
  -- t_singer_song 是中间表，中间表.外键 = 表1.主键
  RIGHT JOIN t_singer_song ON t_singer_song.song_id = t_song.id
  -- t_singer 是主表2，中间表.外键 = 表2.主键
  RIGHT JOIN t_singer ON t_singer_song.singer_id = t_singer.id
);
```

查询结果如下：

| song_id | song_name |     song_cover     | singer_id | singer_name | singer_sex |
| :-----: | :-------: | :----------------: | :-------: | :---------: | :--------: |
|    1    |  七里香   | https://七里香.jpg |     1     |   周杰伦    |     ''     |
|    2    |   屋顶    |  https://屋顶.jpg  |     1     |   周杰伦    |     ''     |
|    2    |   屋顶    |  https://屋顶.jpg  |     4     |    温岚     |     女     |
|    3    | 风吹麦浪  |         ''         |     2     |    李健     |     男     |
|    3    | 风吹麦浪  |         ''         |     5     |    孙俪     |     女     |
|    4    |    画     |   https://画.jpg   |   NULL    |    NULL     |    NULL    |
|    5    |   成都    |  https://成都.jpg  |   NULL    |    NULL     |    NULL    |
|  NULL   |   NULL    |        NULL        |     3     |   梁静茹    |     女     |
