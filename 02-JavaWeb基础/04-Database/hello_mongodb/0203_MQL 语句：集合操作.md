**备注类型**一个数据库里可以有多个集合（即多张表）

## 一、创建集合

> 注意：MongoDB 是数据驱动结构，而不是结构驱动数据，所以 MongoDB 里的集合没有固定的数据结构、也就是说没有固定的字段，只有集合里的每个文档（即每条数据）才有数据结构（即字段），所以创建集合非常简单，不需要像 MySQL 里创建表那样提前指定表的所有字段。集合创建出来后空着放那就行了，后面往里放什么数据都行，因为集合里每条数据的结构可以不同

```javascript
db.createCollection("product");
```

## 二、删除集合

> 注意：当集合不存在时，删除集合不会报错，所以不需要判断存不存在

```SQL
db.product.drop();
```

## 三、修改集合

> 比如我们的项目已经运行维护一段时间了，集合里已经有一堆真实数据了，后续迭代中我们需要修改集合的一些信息，而不能删除集合重新创建

#### 1、修改集合名

```javascript
// db.旧集合名.renameCollection("新集合名")
db.product.renameCollection("products");
```

#### 2、添加新字段、修改字段的数据类型等

```javascript
// MongoDB 是数据驱动结构，而不是结构驱动数据，所以 MongoDB 里的集合没有固定的数据结构、也就是说没有固定的字段，只有集合里的每个文档（即每条数据）才有数据结构（即字段）
// 所以不存在给集合添加新字段的操作，而是存在给集合里每条数据添加新字段的操作，这个下一篇会说到
```

## 补充一：MQL | BSON 支持的数据类型

#### 1、布尔类型

| **类型**    | 备注                  |
| ----------- | --------------------- |
| **Boolean** | **常用，true、false** |

#### 2、整型

| 类型              | 占用内存（Byte） | 范围                      | 备注                         |
| ----------------- | ---------------- | ------------------------- | ---------------------------- |
| **Int32**         | 4                | [-2147483648, 2147483647] | **常用，足够表示 9 位数字**  |
| **Int64（Long）** | 8                | [-2^63, 2^63-1]           | **常用，足够表示 19 位数字** |
| **ObjectId**      | 12               | 特殊结构                  | **常用，默认主键**           |

#### 3、浮点型

| **类型**       | 占用内存（Byte） | 备注                                                         |
| -------------- | ---------------- | ------------------------------------------------------------ |
| **Double**     | 8                | **常用**                                                     |
| **Decimal128** | 16               | **类似于 Java 里的 BigDecimal，如果涉及到钱的计算，就一定要用DECIMAL** |

```javascript
// 通常写，默认就是 Double
{ price: 19.99 }

// 如果涉及钱，手动指明是 Decimal128，NumberDecimal() 只是 Decimal128 的构造方法、不是类型
{ price: NumberDecimal("19.99") }
```

#### 4、字符串类型

| **类型**   | 备注                     |
| ---------- | ------------------------ |
| **String** | **常用，总是变长字符串** |

#### 5、数组类型（MongoDB 的核心优势）

| **类型**  | 备注     |
| --------- | -------- |
| **Array** | **常用** |

```javascript
// MongoDB 的字段天然支持数组类型，所以我们可以极其方便简单地存储数组类型的数据
// 而在 MySQL 里这种情况一般都得通过多表和外键来实现，MongoDB 里没有“表关联”
{
  "id": 1001,
  "name": "张三",
  "sex": "男",
  "age":  18,
  "address": "杭州市上城区",
  "goods": [ // 可以直接把这个数组存进 goods 字段里
    {
      "id": 10001,
      "name": "手机",
      "price": 5000,
      "desc": "很好用的手机",
      "picture": "https://xxx.jpg"
    },
    {
      "id": 10002,
      "name": "电脑",
      "price": 8000,
      "desc": "很好用的电脑",
      "picture": "https://xxx.jpg"
    }
  ]
}
```

#### 6、嵌套文档类型（即嵌套 Map、MongoDB 的灵魂）

| **类型**              | 备注     |
| --------------------- | -------- |
| **Embedded Document** | **常用** |

```javascript
// MongoDB 的字段天然支持 Map 类型，所以我们可以极其方便简单地存储 Map 类型的数据
// 而在 MySQL 里这种情况一般都得通过多表和外键来实现，MongoDB 里没有“表关联”
{
  "id": 1001,
  "name": "张三",
  "sex": "男",
  "age":  18,
  "address": { // 可以直接把这个 Map 存进 address 字段里
    "code": 330110,
    "name": "杭州市上城区"
  }
}
```

#### 7、二进制类型

| **类型** | 备注                                                         |
| -------- | ------------------------------------------------------------ |
| Binary   | 比如文本、图片、音频、视频等文件的二进制数据直接存储进数据库里时<br />但是大文件一般不用直接存 MongoDB，而是用 GridFS |

#### 8、日期类型

| **类型** | 备注                                                         |
| -------- | ------------------------------------------------------------ |
| **Date** | **常用，既有日期部分、也有时分秒部分，格式为 YYYY-MM-DD HH:mm:ss，可以认为无范围限制** |

```javascript
// 存储用户时，手动添加 createTime、updateTime 字段
db.user.insertOne({
  name: "张三",
  createTime: new Date(),
  updateTime: new Date()
});

// 更新用户时，手动更新 updateTime 字段 
db.user.updateOne(
  { name: "张三" },
  {
    $set: {
      name: "张三三",
      updateTime: new Date()
    }
  }
);
```

使用 Date 的实践：服务器数据库里永远存储 0 时区的时间，客户端拿到 0 时区的时间后转成自己所在时区的时间展示

- 数据库存 UTC
- 服务端用 UTC
- 客户端展示时自己转换时区

## 补充二：数组类型字段的元素操作（学了后两篇再返回来看）

#### 1、添加数组字段

给 iPhoneX 这条数据添加一个 designerList 的数组类型字段

```javascript
db.product.updateMany(
	{ "name": "iPhoneX" },
	{
		$set: {
			"designerList": []
		}
	}
);
```

#### 2、给数组字段里添加元素

给 iPhoneX 这条数据的 designerList 字段里添加元素**（本质其实就是更新这个字段的值，只不过不是用 $set 整个覆盖、而是用 $push 或 $addToSet 追加，push 的时候不会自动判断数组里有没有这个元素、所以可能重复，addToSet 的时候会自动判断数组里有没有这个元素、没有的话才会添加进去、所以不可能重复）**

* 单个添加

```javascript
// 找到 name = iPhoneX 的这条数据
// 给这条数据 designerList 字段里 push 一个 张三 进去
db.product.updateMany(
	{ "name": "iPhoneX" },
	{
		$push: {
			"designerList": {
				"name": "张三",
				"age": 33,
				"sex": "男"
			}
		}
	}
);

// 找到 name = iPhoneX 的这条数据
// 给这条数据 designerList 字段里 addToSet 一个 张三 进去
db.product.updateMany(
	{ "name": "iPhoneX" },
	{
		$addToSet: {
			"designerList": {
				"name": "张三",
				"age": 33,
				"sex": "男"
			}
		}
	}
);
```

* 批量添加

```javascript
// 找到 name = iPhoneX 的这条数据
// 给这条数据 designerList 字段里迭代 push 李四、王五、赵六 进去
db.product.updateMany(
	{ "name": "iPhoneX" },
	{
		$push: {
			"designerList": {
				$each: [
					{ "name": "李四", "age": 44, "sex": "女" },
					{ "name": "王五", "age": 55, "sex": "男" },
					{ "name": "赵六", "age": 66, "sex": "女" }
				]
			}
		}
	}
);

// 找到 name = iPhoneX 的这条数据
// 给这条数据 designerList 字段里迭代 addToSet 赵六、孙七、钱八 进去
db.product.updateMany(
	{ "name": "iPhoneX" },
	{
		$addToSet: {
			"designerList": {
				$each: [
					{ "name": "孙七", "age": 77, "sex": "女" },
					{ "name": "钱八", "age": 88, "sex": "男" }
				]
			}
		}
	}
);
```

#### 3、删除数组字段里的元素

删除 iPhoneX 这条数据的 designerList 字段里的元素**（本质其实就是更新这个字段的值，只不过不是用 $set 整个覆盖、而是用 $pull 或 $pop 删除指定的元素，$pull 类似于 removeObject、$pop 用来删除头元素或尾元素、没有 removeObjectAtIndex 这种）**

* 单个删除

```javascript
// 找到 name = iPhoneX 的这条数据
// pull 删除这条数据 designerList 字段里的 孙七 元素
db.product.update(
	{ "name": "iPhoneX" },
	{
		$pull: {
			"designerList": {
				"name": "孙七"
			}
		}
	}
);

// 找到 name = iPhoneX 的这条数据
// pop 删除这条数据 designerList 字段里的头元素或尾元素
db.product.update(
	{ "name": "iPhoneX" },
	{
		$pop: {
			"designerList": 1 // 1 代表删除尾元素
		}
	}
);
db.product.update(
	{ "name": "iPhoneX" },
	{
		$pop: {
			"designerList": -1 // -1 代表删除头元素
		}
	}
);
```

* 批量删除

```javascript
// 找到 name = iPhoneX 的这条数据
// pull + in 批量删除这条数据 designerList 字段里的 张三、李四、王五 元素
db.product.update(
	{ "name": "iPhoneX" },
	{
		$pull: {
			"designerList": {
				"name": {
					$in: ["张三", "李四", "王五"]
				}
			}
		}
	}
);
```

#### 4、修改数组字段里的元素

修改 iPhoneX 这条数据的 designerList 字段里的元素**（本质其实就是更新这个字段的值）**

* 通过索引修改，类似于 replaceObjectAtIndex(index, newObj)

```javascript
// 找到 name = iPhoneX 的这条数据
// set 修改这条数据 designerList 字段里 index = 0 的元素为 首席设计师-刘大
db.product.update(
	{ "name": "iPhoneX" },
	{
		$set: {
			"designerList.0.name": "首席设计师-刘大"
		}
	}
);
```

* 通过元素修改，类似于 replaceObject(oldObj, newObj)

```javascript
// 找到 name = iPhoneX 的这条数据，再找到这条数据 designerList 字段里值为 王五 的元素
// set 修改相应元素的值为 王五五（designerList.$ 其实就是上面找到的元素）
db.product.update(
	{
		"name": "iPhoneX",
		"designerList.name": "王五"
	},
	{
		$set: {
			"designerList.$.name": "王五五"
		}
	}
);
```

#### 5、把数组字段作为查询条件时的匹配规则

* 完全匹配：数据库里数组的元素、元素顺序，必须和我们这里提供的查询数组的元素、元素顺序一模一样，才能查询出来

```javascript
db.product.find({
	"designerList": [
		{
				"name": "首席设计师-刘大",
				"age": 66,
				"sex": "女"
		},
		{
				"name": "孙七",
				"age": 77,
				"sex": "女"
		},
		{
				"name": "钱八",
				"age": 88,
				"sex": "男"
		},
		{
				"name": "李四",
				"age": 44,
				"sex": "女"
		},
		{
				"name": "王五五",
				"age": 55,
				"sex": "男"
		}
	]
});
```

* 全包含匹配：数据库里数组的元素，只要包含全部我们这里提供的查询数组的元素，就能查询出来

```javascript
db.product.find({
	"designerList": {
		$all: [
			{
				"name": "孙七",
				"age": 77,
				"sex": "女"
			},
			{
				"name": "钱八",
				"age": 88,
				"sex": "男"
			}
		]
	}
});

db.product.find({
	"designerList.name": {
		$all: ["孙七", "钱八"]
	}
});
```

* 任一包含匹配：数据库里数组的元素，只要包含任意一个我们这里提供的查询数组的元素，就能查询出来，查询数组的元素只有一个时，可以省略 $in

```javascript
db.product.find({
	"designerList.name": {
		$in: ["孙七", "钱八八"]
	}
});
db.product.find({
	"designerList.name": "孙七"
});
```

* 按数组长度查询：只要长度能匹配上，就能查询出来

```javascript
db.product.find({
	"designerList": {
		$size: 5
	}
});
```



