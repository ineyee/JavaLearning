**备注类型**一个数据库里可以有多个集合（即多张表）

## 一、创建集合

> 注意：MongoDB 是数据驱动结构，而不是结构驱动数据，所以 MongoDB 里的集合没有固定的数据结构、也就是说没有固定的字段，只有集合里的每个文档（即每条数据）才有数据结构（即字段），所以创建集合非常简单，不需要像 MySQL 里创建表那样提前指定表的所有字段。集合创建出来后空着放那就行了，后面往里放什么数据都行，因为集合里每条数据的结构可以不同

```javascript
db.createCollection("product");
```

## 二、删除集合

> 注意：当集合不存在时，删除集合不会报错，所以不需要判断存不存在

```SQL
db.product.drop();
```

## 三、修改集合

> 比如我们的项目已经运行维护一段时间了，集合里已经有一堆真实数据了，后续迭代中我们需要修改集合的一些信息，而不能删除集合重新创建

#### 1、修改集合名

```javascript
// db.旧集合名.renameCollection("新集合名")
db.product.renameCollection("products");
```

#### 2、添加新字段、修改字段的数据类型等

```javascript
// MongoDB 是数据驱动结构，而不是结构驱动数据，所以 MongoDB 里的集合没有固定的数据结构、也就是说没有固定的字段，只有集合里的每个文档（即每条数据）才有数据结构（即字段）
// 所以不存在给集合添加新字段的操作，而是存在给集合里每条数据添加新字段的操作，这个下一篇会说到
```

## 补充一：MQL | BSON 支持的数据类型

#### 1、布尔类型

| **类型**    | 备注                  |
| ----------- | --------------------- |
| **Boolean** | **常用，true、false** |

#### 2、整型

| 类型              | 占用内存（Byte） | 范围                      | 备注                         |
| ----------------- | ---------------- | ------------------------- | ---------------------------- |
| **Int32**         | 4                | [-2147483648, 2147483647] | **常用，足够表示 9 位数字**  |
| **Int64（Long）** | 8                | [-2^63, 2^63-1]           | **常用，足够表示 19 位数字** |
| **ObjectId**      | 12               | 特殊结构                  | **常用，默认主键**           |

#### 3、浮点型

| **类型**       | 占用内存（Byte） | 备注                                                         |
| -------------- | ---------------- | ------------------------------------------------------------ |
| **Double**     | 8                | **常用**                                                     |
| **Decimal128** | 16               | **类似于 Java 里的 BigDecimal，如果涉及到钱的计算，就一定要用DECIMAL** |

```javascript
// 通常写，默认就是 Double
{ price: 19.99 }

// 如果涉及钱，手动指明是 Decimal128，NumberDecimal() 只是 Decimal128 的构造方法、不是类型
{ price: NumberDecimal("19.99") }
```

#### 4、字符串类型

| **类型**   | 备注                     |
| ---------- | ------------------------ |
| **String** | **常用，总是变长字符串** |

#### 5、数组类型（MongoDB 的核心优势）

| **类型**  | 备注     |
| --------- | -------- |
| **Array** | **常用** |

```javascript
// MongoDB 的字段天然支持数组类型，所以我们可以极其方便简单地存储数组类型的数据
// 而在 MySQL 里这种情况一般都得通过多表和外键来实现，MongoDB 里没有“表关联”
{
  "id": 1001,
  "name": "张三",
  "sex": "男",
  "age":  18,
  "address": "杭州市上城区",
  "goods": [ // 可以直接把这个数组存进 goods 字段里
    {
      "id": 10001,
      "name": "手机",
      "price": 5000,
      "desc": "很好用的手机",
      "picture": "https://xxx.jpg"
    },
    {
      "id": 10002,
      "name": "电脑",
      "price": 8000,
      "desc": "很好用的电脑",
      "picture": "https://xxx.jpg"
    }
  ]
}
```

#### 6、嵌套文档类型（即嵌套 Map、MongoDB 的灵魂）

| **类型**              | 备注     |
| --------------------- | -------- |
| **Embedded Document** | **常用** |

```javascript
// MongoDB 的字段天然支持 Map 类型，所以我们可以极其方便简单地存储 Map 类型的数据
// 而在 MySQL 里这种情况一般都得通过多表和外键来实现，MongoDB 里没有“表关联”
{
  "id": 1001,
  "name": "张三",
  "sex": "男",
  "age":  18,
  "address": { // 可以直接把这个 Map 存进 address 字段里
    "code": 330110,
    "name": "杭州市上城区"
  }
}
```

#### 7、二进制类型

| **类型** | 备注                                                         |
| -------- | ------------------------------------------------------------ |
| Binary   | 比如文本、图片、音频、视频等文件的二进制数据直接存储进数据库里时<br />但是大文件一般不用直接存 MongoDB，而是用 GridFS |

#### 8、日期类型

| **类型** | 备注                                                         |
| -------- | ------------------------------------------------------------ |
| **Date** | **常用，既有日期部分、也有时分秒部分，格式为 YYYY-MM-DD HH:mm:ss，可以认为无范围限制** |

```javascript
// 存储用户时，手动添加 createTime、updateTime 字段
db.user.insertOne({
  name: "张三",
  createTime: new Date(),
  updateTime: new Date()
});

// 更新用户时，手动更新 updateTime 字段 
db.user.updateOne(
  { name: "张三" },
  {
    $set: {
      name: "张三三",
      updateTime: new Date()
    }
  }
);
```

使用 Date 的实践：服务器数据库里永远存储 0 时区的时间，客户端拿到 0 时区的时间后转成自己所在时区的时间展示

- 数据库存 UTC
- 服务端用 UTC
- 客户端展示时自己转换时区

## 补充二：索引（学了后两篇再返回来看）

#### 1、索引是什么

###### 1.1 形象地说

我们可以把一个集合看作是一本书，把集合的一条数据看作是书的一页，那么集合的索引就是书的目录。

如果一本书没有目录的话，那么厚的一本书，我们要找某一页就只能从第一页翻到最后一页，查询效率非常低。而有了目录，我们就可以根据目录直接定位到目标页，查询效率飙升。同理如果一个集合没有索引的话，那么大数据量的一个集合，我们要找某一条数据就只能从第一条数据逐条扫描到最后一条，查询效率非常低、接口响应慢。而有了索引，我们就可以根据索引直接定位到目标数据，查询效率飙升。**总之索引就是为了提升查询效率的。**

###### 1.2 举例子说

比如我们的集合里有如下数据：

```json
// 第一条
{
    "_id": ObjectId("699e6aac131e0d5a83054acd"),
    "name": "iPhoneX 8GB",
    "desc": "初代全面屏",
    "price": 8888,
    "deleted": 0
}

// 第二条
{
    "_id": ObjectId("699e6aac131e0d5a83054ad0"),
    "name": "华为 Mate70 8GB",
    "price": 6666,
    "deleted": 0
}

// 第三条
{
    "_id": ObjectId("699e6aac131e0d5a83054ad1"),
    "name": "国产小米 10 8GB",
    "price": 7777,
    "deleted": 0
}
```

当我们执行如下查询时：

```javascript
db.product.find({ "name": "华为 Mate70 8GB" });
```

**没有索引的情况下，MongoDB 默认是全表扫描（Collection Scan、COLLSCAN），它会从第一条数据逐条扫描到最后一条，查询效率非常低，时间复杂度为 O(n)：**

```
第一条 → 不匹配
第二条 → 匹配
第三条 → 不匹配
```

**而如果我们用 name 字段做了索引，那么 MongoDB 就会用所有数据 name 字段的值作为 key、该值所属的那条数据的唯一标识的指针作为 value（MongoDB 里一般就是 \_id 字段）构建一个一个的索引节点，然后再按照我们的设置对所有的索引节点进行升序或降序排序、排序规则是用 name 字段的值的 UTF-8 编码值进行比较，索引节点排序完成后整颗索引树（B 树）就定型了，因此既然索引树上的所有索引节点都已经有顺序了，那么后续查询时就类似于二分查找。一个集合可以拥有多颗索引树、只需要用不同的字段做索引即可。**索引树跟集合里的原数据是分开存储的独立存储单元、能靠唯一标识的指针找到原数据，name 索引树上每个索引节点里存储的大概是：

```json
// 索引节点一
{"iPhoneX 8GB": ObjectId("699e6aac131e0d5a83054acd")}

// 索引节点二
{"华为 Mate70 8GB": ObjectId("699e6aac131e0d5a83054ad0")}

// 索引节点三
{"国产小米 10 8GB": ObjectId("699e6aac131e0d5a83054ad1")}
```

**此外我们需要知道，每个集合都拥有一颗默认的索引树，就是用 \_id 字段做的索引，\_id 索引树上每个索引节点里存储的大概是：**

```json
// 索引节点一
{ObjectId("699e6aac131e0d5a83054acd"): 数据在磁盘上的物理地址 1}

// 索引节点二
{ObjectId("699e6aac131e0d5a83054ad0"): 数据在磁盘上的物理地址 2}

// 索引节点三
{ObjectId("699e6aac131e0d5a83054ad1"): 数据在磁盘上的物理地址 3}
```

此时我们再去执行同样的查询：

```javascript
db.product.find({ "name": "华为 Mate70 8GB" });
```

**有索引的情况下，MongoDB 就是索引扫描（Index Scan、IXSCAN），不再是全表扫描了，查询效率飙升，时间复杂度为 O(log n)：**

```
先拿着【华为 Mate70 8GB】这个值去 name 索引树里通过二分查找快速定位到【{"华为 Mate70 8GB": ObjectId("699e6aac131e0d5a83054ad0")}】这个节点

然后再拿着【ObjectId("699e6aac131e0d5a83054ad0")】这个 _id 去 _id 索引树里通过二分查找快速定位到【{ObjectId("699e6aac131e0d5a83054ad0"): 数据在磁盘上的物理地址 2}】这个节点

然后再拿着【数据在磁盘上的物理地址 2】直接去集合数据存储区把相应的数据给读取出来
```

#### 2、怎么使用索引

###### 2.1 查看 MQL 查询语句是否使用了索引扫描

* 在原来的查询语句后面加上个 .explain("executionStats")

```javascript
// 通过 name 字段查询
db.product.find({ "name": "华为 Mate70 8GB" }).explain("executionStats");
```

```javascript
// 通过 _id 字段查询
db.product.find({ "_id": ObjectId("699e6aac131e0d5a83054ad0B") }).explain("executionStats");
```

* 在输出的内容里重点关注下面几个字段

> * "stage": "COLLSCAN" // 代表使用的是全表扫描
> * "stage": "IXSCAN" // 代表使用的是索引扫描
>   * "indexName": "\_id\_" // 代表使用的是哪个索引
>
> 
>
> // 如果使用的是全表扫描，那这两个值可能相差很大
> // 如果使用的是索引扫描，那这两个值应该相差不大
>
> * "totalDocsExamined": 1000 // 代表本次查询一共扫描了 1000 条数据
> * "nReturned": 10 // 代表本次查询返回了 10 条数据
>
> 
>
> * "executionTimeMillis": NumberInt("0") // 代表本次查询耗时多少 ms

```json
// 我们没用 name 做索引，所以输出内容如下
"executionTimeMillis": NumberInt("9")

"nReturned": NumberInt("1")
"totalDocsExamined": NumberInt("9")

"stage": "COLLSCAN"
```

```javascript
// 默认用 _id 做索引，所以输出内容如下
"executionTimeMillis": NumberInt("0")

"nReturned": NumberInt("1")
"totalDocsExamined": NumberInt("1")

"stage": "EXPRESS_IXSCAN",
"indexName": "_id_",
```

###### 2.2 给集合添加索引

###### —— 2.2.1 单字段索引

> 实际开发中，如果查询条件真得只有一个字段那就用单字段索引，但这种场景很少见

只用一个字段做索引，就是单字段索引，比如我们用 name 字段做索引：

```javascript
// name：代表用 name 字段做索引
// 1：代表 name 索引树上的索引节点按升序排序
// -1：代表降序排序
db.product.createIndex({ "name": 1 });
```

**单字段索引比较简单，MQL 查询语句里得包含该字段才有机会走索引扫描，否则就会走全表扫描：**

```javascript
// 包含 name 字段，会走索引扫描
db.product.find({ "name": "华为 Mate70 8GB" }).explain("executionStats");
// 包含 name 字段，会走索引扫描
db.product.find({ "price": { $gte: 9999 }, "deleted": 0, "name": "华为 Mate70 8GB" }).explain("executionStats");

// 不包含 name 字段，会走全表扫描
db.product.find({ "price": { $gte: 9999 }, "deleted": 0 }).explain("executionStats");
```

###### —— 2.2.2 复合字段索引

> 实际开发中，绝大多数场景都是一个查询组合了好几个查询条件，所以复合字段索引更常用

同时用多个字段做索引，就是复合字段索引，比如我们用 price 和 deleted 字段做复合字段索引：

```javascript
// price、deleted：代表用 price、deleted 字段做复合字段索引
// 1：代表 price 按降序排序
// -1：代表 deleted 升序排序
db.product.createIndex({ "price": -1, "deleted": 1 });
```

**复合字段索引遵循最左索引字段原则（即添加索引时的第一个字段），MQL 查询语句里得包含最左索引字段才有机会走索引扫描，否则就会走全表扫描：**

```javascript
// 包含最左索引字段 price，会走索引扫描（但是对复合索引的利用不够充分，因为没用到第二个索引字段）
db.product.find({ "price": { $gte: 9999 } }).explain("executionStats");
// 包含最左索引字段 price，会走索引扫描（并且对复合索引的利用够充分，因为用到了第二个索引字段）
db.product.find({ "price": { $gte: 9999 }, "deleted": 0 }).explain("executionStats");
// 包含最左索引字段 price，会走索引扫描（跟上面一条查询其实一样的效果，是否走索引跟 MQL 查询语句里查询条件的顺序没有关系，MongoDB 会自动重排查询条件来提升查询效率）
db.product.find({ "deleted": 0, "price": { $gte: 9999 } }).explain("executionStats");
// 包含最左索引字段 price，会走索引扫描
db.product.find({ "price": { $gte: 9999 }, "deleted": 0, "name": "华为 Mate70 8GB" }).explain("executionStats");

// 不包含最左索引字段 price，会走全表扫描
db.product.find({ "deleted": 0 }).explain("executionStats");
// 不包含最左索引字段 price，会走全表扫描
db.product.find({ "price": { $gte: 9999 }, "name": "华为 Mate70 8GB" }).explain("executionStats");
```

###### 2.3 删除集合的索引

```javascript
// 按索引名字删除索引
db.product.dropIndex("name_1");
db.product.dropIndex("price_-1_deleted_1");
```

###### 2.4 查看当前集合有哪些索引

```javascript
db.product.getIndexes();
```

#### 3、添加索引的建议

添加索引固然能**提高数据查询效率**，但是添加索引后每一次对数据的增删改操作都会影响索引树的变化，也就是说索引会**降低数据写入效率**。所以一定要根据实际业务场景的查询条件来使用索引，千万不要用每个字段都做索引。

比如我们 product 的数据结构为：

```json
{
  "_id": ObjectId("699e6aac131e0d5a83054acd"),
  "name": "iPhoneX 8GB",
  "desc": "初代全面屏",
  "price": 8888,
  "deleted": 0
}
```

那么在产品详情界面，无非就是根据 id 查询一下 deleted == 0 的某条数据，所以可以创建一个复合字段索引：





