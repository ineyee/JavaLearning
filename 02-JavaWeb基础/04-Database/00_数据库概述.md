## 一、数据库是什么

任何软件系统都需要存储大量的数据，比如用户信息（姓名、性别、年龄、地址）、商品信息（商品名称、商品价格、商品描述、商品宣传图）等，而数据库就是用来存储数据的，它有如下特点：

* 结构化组织：数据以表格（关系型）或文档（非关系型）等形式组织
* 持久化存储：数据可以长期保存在存储介质中，断电不丢失
* 高效操作：提供增删改查等操作来快速处理数据
* 安全访问：提供数据保护机制来支持多用户并发访问同一数据（比如 MySQL “自动”有行级锁、MongoDB “自动”有文档锁，都是针对某条数据级别的锁，再加上我们手动编写事务，就可以保证业务数据的安全）

## 二、为什么需要数据库

如果没有数据库，那大量的数据就得存储在文件里，但是文件系统有很多缺点：

* 很难以合适的方式来组织数据，比如用户信息存储到一个文件里，商品信息存储到一个文件里，但是这两个文件里的信息有一定的关联，是不太好关联的
* 当文件较小时，对文件进行整体的增删改查操作可能还好，但是当文件大起来后，我们如果想对文件里数据的某一小部分数据进行修改、删除之类的操作是不行的
* 文件系统的话，发生并发访问时可能会发生阻塞或覆盖，数据不安全
* ......

## 三、关系型数据库和非关系型数据库

#### 1、关系型数据库

代表产品：MySQL

特点：
* 结构化组织：每条数据都存储在以行和列组成的二维表里，表与表之间又可以通过外键来关联形成一对一、一对多、多对多的关系
* 使用标准 SQL 语句来对数据进行增删改查操作

举例：以存储用户信息 + 商品信息为例，通常需要拆分成多个表，通过外键来关联

**用户表（User）**

|id（主键）|name|sex|age|address|
|:-:|:-:|:-:|:-:|:-:|
|1001|张三|男|18|杭州市上城区|
|1002|李四|女|19|杭州市拱墅区|

**商品表（Goods）**

| id（主键） | name | price |     desc     |     picture     | user_id（外键） |
| :--------: | :--: | :---: | :----------: | :-------------: | :-------------: |
|   10001    | 手机 | 5000  | 很好用的手机 | https://xxx.jpg |      1001       |
|   10002    | 电脑 | 8000  | 很好用的电脑 | https://xxx.jpg |      1002       |

#### 2、非关系型数据库

代表产品：MongoDB

特点：
* 结构化组织：数据以 BSON 形式（JSON 的扩展）直接存储在文档里
* MQL 语句存取数据更加灵活，但是数据可能会出现重复存储

举例：以存储用户信息 + 商品信息为例，我们为每个用户创建一个文档，**核心思想是一个文档 = 一条数据 = 一个完整对象**

```json
// 用户一的文档（直接嵌入订单信息）
{
  "id": 1001,
  "name": "张三",
  "sex": "男",
  "age":  18,
  "address": "杭州市上城区",
  "goods": [
    {
      "id": 10001,
      "name": "手机",
      "price": 5000,
      "desc": "很好用的手机",
      "picture": "https://xxx.jpg"
    }
  ]
}
```

```json
// 用户二的文档（直接嵌入订单信息）
{
  "id": 1002,
  "name": "李四",
  "sex": "女",
  "age":  18,
  "address": "杭州市拱墅区",
  "goods": [
    {
      "id": 10002,
      "name": "电脑",
      "price": 8000,
      "desc": "很好用的电脑",
      "picture": "https://xxx.jpg"
    }
  ]
}
```

> 这里需要注意：
>
> 非关系型数据库的文档和文件在形式上看起来几乎一样，但它们的底层实现完全不同，数据库就是数据库，文件存储就是文件存储
>
> 比如非关系型数据库提供了专门的 CRUD API 来完成文档里数据的增删改查操作，而文件存储则需要我们自己手动读写文件等；又比如非关系型数据库给我们提供了专门的锁机制来避免并发访问时的数据冲突问题，而文件存储发生并发访问时可能会发生阻塞或覆盖

#### 3、概念对应关系

| MySQL            | MongoDB                    | 解释说明                                                     |
| ---------------- | -------------------------- | ------------------------------------------------------------ |
| database 数据库  | database 数据库            | MongoDB 里的数据库和 MySQL 里的数据库概念一样，里面存放着多个集合 |
| table 表         | collection 集合            | MongoDB 里的集合对应 MySQL 里的表、一个集合就是一张表，里面存放着多条数据<br />**表里每条数据的字段结构必须相同，但是集合里每条数据的字段结构可以不同** |
| row 行           | document 文档              | MongoDB 里的文档对应 MySQL 里的行、一个文档就是一条数据，里面存放着多个字段<br />**一条数据的大小限制是 16MB** |
| column 列        | filed 字段                 | MongoDB 里的字段对应 MySQL 里的列、是一条数据的某个属性      |
| primary key 主键 | primary key 主键           | MongoDB 里的主键和 MySQL 里的主键概念一样<br />只不过 MySQL 里我们需要自己创建这个字段，然后设置它自增或雪花算法<br />而 MongoDB 里我们不需要自己创建这个字段，MongoDB 会自动为每条数据都添加一个 ObjectId 类型的 _id 字段作为主键，类似于 UUID 的东西 |
| table joins      |                            | MongoDB 不建议像 MySQL 那样用表连接来实现对象与对象之间的一对一、一对多、多对多关系，而是建议用对象嵌套另外一个对象、对象嵌套另外一个对象数组的方式来实现这些关系 |
| index            | index                      | 大家都有索引                                                 |
| 需要预定义表结构 | 无需预定义表结构，非常灵活 |                                                              |

#### 4、选择

| 关系型数据库                                                 | 非关系型数据库                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 事务处理非常可靠<br />多表关系非常成熟，所以多表间的复杂联查非常自然 | 做不了前者那种级别的可靠事务<br />多表间的复杂联查需要我们自己拼 |
| 建模相对复杂<br />后续扩展字段总是得修改表                   | 建模简单且直观<br />后续扩展字段直接在 Json 里加就行非常简单 |

**所以关系型数据库适合对事务要求较高、强关系的系统，如跟钱相关的支付、金额、订单等系统，跟账号相关的用户、权限、订阅等系统**

**所以非关系型数据库适合对事务要求不高、数据结构变化多的系统，如日志系统、内容型平台的系统（数据结构可能频繁迭代变化）**